{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Project\\\\Front_end\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Project\\\\Front_end\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _ = require(\"lodash\");\nvar Cell = require(\"./Cell\");\nvar Row = require(\"./Row\");\nvar Column = require(\"./Column\");\nvar Range = require(\"./Range\");\nvar Relationships = require(\"./Relationships\");\nvar xmlq = require(\"./xmlq\");\nvar regexify = require(\"./regexify\");\nvar addressConverter = require(\"./addressConverter\");\nvar ArgHandler = require(\"./ArgHandler\");\nvar colorIndexes = require(\"./colorIndexes\");\nvar PageBreaks = require(\"./PageBreaks\");\n\n// Order of the nodes as defined by the spec.\nvar nodeOrder = [\"sheetPr\", \"dimension\", \"sheetViews\", \"sheetFormatPr\", \"cols\", \"sheetData\", \"sheetCalcPr\", \"sheetProtection\", \"autoFilter\", \"protectedRanges\", \"scenarios\", \"autoFilter\", \"sortState\", \"dataConsolidate\", \"customSheetViews\", \"mergeCells\", \"phoneticPr\", \"conditionalFormatting\", \"dataValidations\", \"hyperlinks\", \"printOptions\", \"pageMargins\", \"pageSetup\", \"headerFooter\", \"rowBreaks\", \"colBreaks\", \"customProperties\", \"cellWatches\", \"ignoredErrors\", \"smartTags\", \"drawing\", \"drawingHF\", \"legacyDrawing\", \"legacyDrawingHF\", \"picture\", \"oleObjects\", \"controls\", \"webPublishItems\", \"tableParts\", \"extLst\"];\n\n/**\n * A worksheet.\n */\nvar Sheet = /*#__PURE__*/function () {\n  // /**\n  //  * Creates a new instance of Sheet.\n  //  * @param {Workbook} workbook - The parent workbook.\n  //  * @param {{}} idNode - The sheet ID node (from the parent workbook).\n  //  * @param {{}} node - The sheet node.\n  //  * @param {{}} [relationshipsNode] - The optional sheet relationships node.\n  //  */\n  function Sheet(workbook, idNode, node, relationshipsNode) {\n    _classCallCheck(this, Sheet);\n    this._init(workbook, idNode, node, relationshipsNode);\n  }\n\n  /* PUBLIC */\n\n  /**\n   * Gets a value indicating whether the sheet is the active sheet in the workbook.\n   * @returns {boolean} True if active, false otherwise.\n   */ /**\n      * Make the sheet the active sheet in the workkbok.\n      * @param {boolean} active - Must be set to `true`. Deactivating directly is not supported. To deactivate, you should activate a different sheet instead.\n      * @returns {Sheet} The sheet.\n      */\n  _createClass(Sheet, [{\n    key: \"active\",\n    value: function active() {\n      var _this = this;\n      return new ArgHandler('Sheet.active').case(function () {\n        return _this.workbook().activeSheet() === _this;\n      }).case('boolean', function (active) {\n        if (!active) throw new Error(\"Deactivating sheet directly not supported. Activate a different sheet instead.\");\n        _this.workbook().activeSheet(_this);\n        return _this;\n      }).handle(arguments);\n    }\n    /**\n     * Get the active cell in the sheet.\n     * @returns {Cell} The active cell.\n     */\n    /**\n    * Set the active cell in the workbook.\n    * @param {string|Cell} cell - The cell or address of cell to activate.\n    * @returns {Sheet} The sheet.\n    */\n    /**\n    * Set the active cell in the workbook by row and column.\n    * @param {number} rowNumber - The row number of the cell.\n    * @param {string|number} columnNameOrNumber - The column name or number of the cell.\n    * @returns {Sheet} The sheet.\n    */\n  }, {\n    key: \"activeCell\",\n    value: function activeCell() {\n      var _this2 = this;\n      var sheetViewNode = this._getOrCreateSheetViewNode();\n      var selectionNode = xmlq.findChild(sheetViewNode, \"selection\");\n      return new ArgHandler('Sheet.activeCell').case(function () {\n        var cellAddress = selectionNode ? selectionNode.attributes.activeCell : \"A1\";\n        return _this2.cell(cellAddress);\n      }).case(['number', '*'], function (rowNumber, columnNameOrNumber) {\n        var cell = _this2.cell(rowNumber, columnNameOrNumber);\n        return _this2.activeCell(cell);\n      }).case('*', function (cell) {\n        if (!selectionNode) {\n          selectionNode = {\n            name: \"selection\",\n            attributes: {},\n            children: []\n          };\n          xmlq.appendChild(sheetViewNode, selectionNode);\n        }\n        if (!(cell instanceof Cell)) cell = _this2.cell(cell);\n        selectionNode.attributes.activeCell = selectionNode.attributes.sqref = cell.address();\n        return _this2;\n      }).handle(arguments);\n    }\n    /**\n     * Gets the cell with the given address.\n     * @param {string} address - The address of the cell.\n     * @returns {Cell} The cell.\n     */\n    /**\n    * Gets the cell with the given row and column numbers.\n    * @param {number} rowNumber - The row number of the cell.\n    * @param {string|number} columnNameOrNumber - The column name or number of the cell.\n    * @returns {Cell} The cell.\n    */\n  }, {\n    key: \"cell\",\n    value: function cell() {\n      var _this3 = this;\n      return new ArgHandler('Sheet.cell').case('string', function (address) {\n        var ref = addressConverter.fromAddress(address);\n        if (ref.type !== 'cell') throw new Error('Sheet.cell: Invalid address.');\n        return _this3.row(ref.rowNumber).cell(ref.columnNumber);\n      }).case(['number', '*'], function (rowNumber, columnNameOrNumber) {\n        return _this3.row(rowNumber).cell(columnNameOrNumber);\n      }).handle(arguments);\n    }\n    /**\n     * Gets a column in the sheet.\n     * @param {string|number} columnNameOrNumber - The name or number of the column.\n     * @returns {Column} The column.\n     */\n  }, {\n    key: \"column\",\n    value: function column(columnNameOrNumber) {\n      var columnNumber = typeof columnNameOrNumber === \"string\" ? addressConverter.columnNameToNumber(columnNameOrNumber) : columnNameOrNumber;\n\n      // If we're already created a column for this column number, return it.\n      if (this._columns[columnNumber]) return this._columns[columnNumber];\n\n      // We need to create a new column, which requires a backing col node. There may already exist a node whose min/max cover our column.\n      // First, see if there is an existing col node.\n      var existingColNode = this._colNodes[columnNumber];\n      var colNode;\n      if (existingColNode) {\n        // If the existing node covered earlier columns than the new one, we need to have a col node to cover the min up to our new node.\n        if (existingColNode.attributes.min < columnNumber) {\n          // Clone the node and set the max to the column before our new col.\n          var beforeColNode = _.cloneDeep(existingColNode);\n          beforeColNode.attributes.max = columnNumber - 1;\n\n          // Update the col nodes cache.\n          for (var i = beforeColNode.attributes.min; i <= beforeColNode.attributes.max; i++) {\n            this._colNodes[i] = beforeColNode;\n          }\n        }\n\n        // Make a clone for the new column. Set the min/max to the column number and cache it.\n        colNode = _.cloneDeep(existingColNode);\n        colNode.attributes.min = columnNumber;\n        colNode.attributes.max = columnNumber;\n        this._colNodes[columnNumber] = colNode;\n\n        // If the max of the existing node is greater than the nre one, create a col node for that too.\n        if (existingColNode.attributes.max > columnNumber) {\n          var afterColNode = _.cloneDeep(existingColNode);\n          afterColNode.attributes.min = columnNumber + 1;\n          for (var _i = afterColNode.attributes.min; _i <= afterColNode.attributes.max; _i++) {\n            this._colNodes[_i] = afterColNode;\n          }\n        }\n      } else {\n        // The was no existing node so create a new one.\n        colNode = {\n          name: 'col',\n          attributes: {\n            min: columnNumber,\n            max: columnNumber\n          },\n          children: []\n        };\n        this._colNodes[columnNumber] = colNode;\n      }\n\n      // Create the new column and cache it.\n      var column = new Column(this, colNode);\n      this._columns[columnNumber] = column;\n      return column;\n    }\n    /**\n     * Gets a defined name scoped to the sheet.\n     * @param {string} name - The defined name.\n     * @returns {undefined|string|Cell|Range|Row|Column} What the defined name refers to or undefined if not found. Will return the string formula if not a Row, Column, Cell, or Range.\n     */\n    /**\n    * Set a defined name scoped to the sheet.\n    * @param {string} name - The defined name.\n    * @param {string|Cell|Range|Row|Column} refersTo - What the name refers to.\n    * @returns {Workbook} The workbook.\n    */\n  }, {\n    key: \"definedName\",\n    value: function definedName() {\n      var _this4 = this;\n      return new ArgHandler(\"Workbook.definedName\").case('string', function (name) {\n        return _this4.workbook().scopedDefinedName(_this4, name);\n      }).case(['string', '*'], function (name, refersTo) {\n        _this4.workbook().scopedDefinedName(_this4, name, refersTo);\n        return _this4;\n      }).handle(arguments);\n    }\n    /**\n     * Deletes the sheet and returns the parent workbook.\n     * @returns {Workbook} The workbook.\n     */\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      this.workbook().deleteSheet(this);\n      return this.workbook();\n    }\n    /**\n     * Find the given pattern in the sheet and optionally replace it.\n     * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n     * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in each cell will be replaced.\n     * @returns {Array.<Cell>} The matching cells.\n     */\n  }, {\n    key: \"find\",\n    value: function find(pattern, replacement) {\n      pattern = regexify(pattern);\n      var matches = [];\n      this._rows.forEach(function (row) {\n        if (!row) return;\n        matches = matches.concat(row.find(pattern, replacement));\n      });\n      return matches;\n    }\n    /**\n     * Gets a value indicating whether this sheet's grid lines are visible.\n     * @returns {boolean} True if selected, false if not.\n     */\n    /**\n    * Sets whether this sheet's grid lines are visible.\n    * @param {boolean} selected - True to make visible, false to hide.\n    * @returns {Sheet} The sheet.\n    */\n  }, {\n    key: \"gridLinesVisible\",\n    value: function gridLinesVisible() {\n      var _this5 = this;\n      var sheetViewNode = this._getOrCreateSheetViewNode();\n      return new ArgHandler('Sheet.gridLinesVisible').case(function () {\n        return sheetViewNode.attributes.showGridLines === 1 || sheetViewNode.attributes.showGridLines === undefined;\n      }).case('boolean', function (visible) {\n        sheetViewNode.attributes.showGridLines = visible ? 1 : 0;\n        return _this5;\n      }).handle(arguments);\n    }\n    /**\n     * Gets a value indicating if the sheet is hidden or not.\n     * @returns {boolean|string} True if hidden, false if visible, and 'very' if very hidden.\n     */\n    /**\n    * Set whether the sheet is hidden or not.\n    * @param {boolean|string} hidden - True to hide, false to show, and 'very' to make very hidden.\n    * @returns {Sheet} The sheet.\n    */\n  }, {\n    key: \"hidden\",\n    value: function hidden() {\n      var _this6 = this;\n      return new ArgHandler('Sheet.hidden').case(function () {\n        if (_this6._idNode.attributes.state === 'hidden') return true;\n        if (_this6._idNode.attributes.state === 'veryHidden') return \"very\";\n        return false;\n      }).case('*', function (hidden) {\n        if (hidden) {\n          var visibleSheets = _.filter(_this6.workbook().sheets(), function (sheet) {\n            return !sheet.hidden();\n          });\n          if (visibleSheets.length === 1 && visibleSheets[0] === _this6) {\n            throw new Error(\"This sheet may not be hidden as a workbook must contain at least one visible sheet.\");\n          }\n\n          // If activate, activate the first other visible sheet.\n          if (_this6.active()) {\n            var activeIndex = visibleSheets[0] === _this6 ? 1 : 0;\n            visibleSheets[activeIndex].active(true);\n          }\n        }\n        if (hidden === 'very') _this6._idNode.attributes.state = 'veryHidden';else if (hidden) _this6._idNode.attributes.state = 'hidden';else delete _this6._idNode.attributes.state;\n        return _this6;\n      }).handle(arguments);\n    }\n    /**\n     * Move the sheet.\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Sheet} The sheet.\n     */\n  }, {\n    key: \"move\",\n    value: function move(indexOrBeforeSheet) {\n      this.workbook().moveSheet(this, indexOrBeforeSheet);\n      return this;\n    }\n    /**\n     * Get the name of the sheet.\n     * @returns {string} The sheet name.\n     */\n    /**\n    * Set the name of the sheet. *Note: this method does not rename references to the sheet so formulas, etc. can be broken. Use with caution!*\n    * @param {string} name - The name to set to the sheet.\n    * @returns {Sheet} The sheet.\n    */\n  }, {\n    key: \"name\",\n    value: function name() {\n      var _this7 = this;\n      return new ArgHandler('Sheet.name').case(function () {\n        return \"\".concat(_this7._idNode.attributes.name);\n      }).case('string', function (name) {\n        _this7._idNode.attributes.name = name;\n        return _this7;\n      }).handle(arguments);\n    }\n    /**\n     * Gets a range from the given range address.\n     * @param {string} address - The range address (e.g. 'A1:B3').\n     * @returns {Range} The range.\n     */\n    /**\n    * Gets a range from the given cells or cell addresses.\n    * @param {string|Cell} startCell - The starting cell or cell address (e.g. 'A1').\n    * @param {string|Cell} endCell - The ending cell or cell address (e.g. 'B3').\n    * @returns {Range} The range.\n    */\n    /**\n    * Gets a range from the given row numbers and column names or numbers.\n    * @param {number} startRowNumber - The starting cell row number.\n    * @param {string|number} startColumnNameOrNumber - The starting cell column name or number.\n    * @param {number} endRowNumber - The ending cell row number.\n    * @param {string|number} endColumnNameOrNumber - The ending cell column name or number.\n    * @returns {Range} The range.\n    */\n  }, {\n    key: \"range\",\n    value: function range() {\n      var _this8 = this;\n      return new ArgHandler('Sheet.range').case('string', function (address) {\n        var ref = addressConverter.fromAddress(address);\n        if (ref.type !== 'range') throw new Error('Sheet.range: Invalid address');\n        return _this8.range(ref.startRowNumber, ref.startColumnNumber, ref.endRowNumber, ref.endColumnNumber);\n      }).case(['*', '*'], function (startCell, endCell) {\n        if (typeof startCell === \"string\") startCell = _this8.cell(startCell);\n        if (typeof endCell === \"string\") endCell = _this8.cell(endCell);\n        return new Range(startCell, endCell);\n      }).case(['number', '*', 'number', '*'], function (startRowNumber, startColumnNameOrNumber, endRowNumber, endColumnNameOrNumber) {\n        return _this8.range(_this8.cell(startRowNumber, startColumnNameOrNumber), _this8.cell(endRowNumber, endColumnNameOrNumber));\n      }).handle(arguments);\n    }\n    /**\n     * Unsets sheet autoFilter.\n     * @returns {Sheet} This sheet.\n     */\n    /**\n    * Sets sheet autoFilter to a Range.\n    * @param {Range} range - The autoFilter range.\n    * @returns {Sheet} This sheet.\n    */\n  }, {\n    key: \"autoFilter\",\n    value: function autoFilter(range) {\n      this._autoFilter = range;\n      return this;\n    }\n    /**\n     * Gets the row with the given number.\n     * @param {number} rowNumber - The row number.\n     * @returns {Row} The row with the given number.\n     */\n  }, {\n    key: \"row\",\n    value: function row(rowNumber) {\n      if (rowNumber < 1) throw new RangeError(\"Invalid row number \".concat(rowNumber, \". Remember that spreadsheets use 1-based indexing.\"));\n      if (this._rows[rowNumber]) return this._rows[rowNumber];\n      var rowNode = {\n        name: 'row',\n        attributes: {\n          r: rowNumber\n        },\n        children: []\n      };\n      var row = new Row(this, rowNode);\n      this._rows[rowNumber] = row;\n      return row;\n    }\n    /**\n     * Get the tab color. (See style [Color](#color).)\n     * @returns {undefined|Color} The color or undefined if not set.\n     */\n    /**\n    * Sets the tab color. (See style [Color](#color).)\n    * @returns {Color|string|number} color - Color of the tab. If string, will set an RGB color. If number, will set a theme color.\n    */\n  }, {\n    key: \"tabColor\",\n    value: function tabColor() {\n      var _this9 = this;\n      return new ArgHandler(\"Sheet.tabColor\").case(function () {\n        var tabColorNode = xmlq.findChild(_this9._sheetPrNode, \"tabColor\");\n        if (!tabColorNode) return;\n        var color = {};\n        if (tabColorNode.attributes.hasOwnProperty('rgb')) color.rgb = tabColorNode.attributes.rgb;else if (tabColorNode.attributes.hasOwnProperty('theme')) color.theme = tabColorNode.attributes.theme;else if (tabColorNode.attributes.hasOwnProperty('indexed')) color.rgb = colorIndexes[tabColorNode.attributes.indexed];\n        if (tabColorNode.attributes.hasOwnProperty('tint')) color.tint = tabColorNode.attributes.tint;\n        return color;\n      }).case(\"string\", function (rgb) {\n        return _this9.tabColor({\n          rgb: rgb\n        });\n      }).case(\"integer\", function (theme) {\n        return _this9.tabColor({\n          theme: theme\n        });\n      }).case(\"nil\", function () {\n        xmlq.removeChild(_this9._sheetPrNode, \"tabColor\");\n        return _this9;\n      }).case(\"object\", function (color) {\n        var tabColorNode = xmlq.appendChildIfNotFound(_this9._sheetPrNode, \"tabColor\");\n        xmlq.setAttributes(tabColorNode, {\n          rgb: color.rgb && color.rgb.toUpperCase(),\n          indexed: null,\n          theme: color.theme,\n          tint: color.tint\n        });\n        return _this9;\n      }).handle(arguments);\n    }\n    /**\n     * Gets a value indicating whether this sheet is selected.\n     * @returns {boolean} True if selected, false if not.\n     */\n    /**\n    * Sets whether this sheet is selected.\n    * @param {boolean} selected - True to select, false to deselected.\n    * @returns {Sheet} The sheet.\n    */\n  }, {\n    key: \"tabSelected\",\n    value: function tabSelected() {\n      var _this10 = this;\n      var sheetViewNode = this._getOrCreateSheetViewNode();\n      return new ArgHandler('Sheet.tabSelected').case(function () {\n        return sheetViewNode.attributes.tabSelected === 1;\n      }).case('boolean', function (selected) {\n        if (selected) sheetViewNode.attributes.tabSelected = 1;else delete sheetViewNode.attributes.tabSelected;\n        return _this10;\n      }).handle(arguments);\n    }\n    /**\n     * Gets a value indicating whether this sheet is rtl (Right To Left).\n     * @returns {boolean} True if rtl, false if ltr.\n     */\n    /**\n    * Sets whether this sheet is rtl.\n    * @param {boolean} rtl - True to rtl, false to ltr (Left To Right).\n    * @returns {Sheet} The sheet.\n    */\n  }, {\n    key: \"rightToLeft\",\n    value: function rightToLeft() {\n      var _this11 = this;\n      var sheetViewNode = this._getOrCreateSheetViewNode();\n      return new ArgHandler('Sheet.rightToLeft').case(function () {\n        return sheetViewNode.attributes.rightToLeft;\n      }).case('boolean', function (rtl) {\n        if (rtl) sheetViewNode.attributes.rightToLeft = true;else delete sheetViewNode.attributes.rightToLeft;\n        return _this11;\n      }).handle(arguments);\n    }\n    /**\n     * Get the range of cells in the sheet that have contained a value or style at any point. Useful for extracting the entire sheet contents.\n     * @returns {Range|undefined} The used range or undefined if no cells in the sheet are used.\n     */\n  }, {\n    key: \"usedRange\",\n    value: function usedRange() {\n      var minRowNumber = _.findIndex(this._rows);\n      var maxRowNumber = this._rows.length - 1;\n      var minColumnNumber = 0;\n      var maxColumnNumber = 0;\n      for (var i = 0; i < this._rows.length; i++) {\n        var row = this._rows[i];\n        if (!row) continue;\n        var minUsedColumnNumber = row.minUsedColumnNumber();\n        var maxUsedColumnNumber = row.maxUsedColumnNumber();\n        if (minUsedColumnNumber > 0 && (!minColumnNumber || minUsedColumnNumber < minColumnNumber)) minColumnNumber = minUsedColumnNumber;\n        if (maxUsedColumnNumber > 0 && (!maxColumnNumber || maxUsedColumnNumber > maxColumnNumber)) maxColumnNumber = maxUsedColumnNumber;\n      }\n\n      // Return undefined if nothing in the sheet is used.\n      if (minRowNumber <= 0 || minColumnNumber <= 0 || maxRowNumber <= 0 || maxColumnNumber <= 0) return;\n      return this.range(minRowNumber, minColumnNumber, maxRowNumber, maxColumnNumber);\n    }\n    /**\n     * Gets the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n  }, {\n    key: \"workbook\",\n    value: function workbook() {\n      return this._workbook;\n    }\n    /**\n     * Gets all page breaks.\n     * @returns {{}} the object holds both vertical and horizontal PageBreaks.\n     */\n  }, {\n    key: \"pageBreaks\",\n    value: function pageBreaks() {\n      return this._pageBreaks;\n    }\n    /**\n     * Gets the vertical page breaks.\n     * @returns {PageBreaks} vertical PageBreaks.\n     */\n  }, {\n    key: \"verticalPageBreaks\",\n    value: function verticalPageBreaks() {\n      return this._pageBreaks.colBreaks;\n    }\n    /**\n     * Gets the horizontal page breaks.\n     * @returns {PageBreaks} horizontal PageBreaks.\n     */\n  }, {\n    key: \"horizontalPageBreaks\",\n    value: function horizontalPageBreaks() {\n      return this._pageBreaks.rowBreaks;\n    }\n    /* INTERNAL */\n    /**\n     * Clear cells that are using a given shared formula ID.\n     * @param {number} sharedFormulaId - The shared formula ID.\n     * @returns {undefined}\n     * @ignore\n     */\n  }, {\n    key: \"clearCellsUsingSharedFormula\",\n    value: function clearCellsUsingSharedFormula(sharedFormulaId) {\n      this._rows.forEach(function (row) {\n        if (!row) return;\n        row.clearCellsUsingSharedFormula(sharedFormulaId);\n      });\n    }\n    /**\n     * Get an existing column style ID.\n     * @param {number} columnNumber - The column number.\n     * @returns {undefined|number} The style ID.\n     * @ignore\n     */\n  }, {\n    key: \"existingColumnStyleId\",\n    value: function existingColumnStyleId(columnNumber) {\n      // This will work after setting Column.style because Column updates the attributes live.\n      var colNode = this._colNodes[columnNumber];\n      return colNode && colNode.attributes.style;\n    }\n    /**\n     * Call a callback for each column number that has a node defined for it.\n     * @param {Function} callback - The callback.\n     * @returns {undefined}\n     * @ignore\n     */\n  }, {\n    key: \"forEachExistingColumnNumber\",\n    value: function forEachExistingColumnNumber(callback) {\n      _.forEach(this._colNodes, function (node, columnNumber) {\n        if (!node) return;\n        callback(columnNumber);\n      });\n    }\n    /**\n     * Call a callback for each existing row.\n     * @param {Function} callback - The callback.\n     * @returns {undefined}\n     * @ignore\n     */\n  }, {\n    key: \"forEachExistingRow\",\n    value: function forEachExistingRow(callback) {\n      _.forEach(this._rows, function (row, rowNumber) {\n        if (row) callback(row, rowNumber);\n      });\n      return this;\n    }\n    /**\n     * Get the hyperlink attached to the cell with the given address.\n     * @param {string} address - The address of the hyperlinked cell.\n     * @returns {string|undefined} The hyperlink or undefined if not set.\n     */\n    /**\n    * Set the hyperlink on the cell with the given address.\n    * @param {string} address - The address of the hyperlinked cell.\n    * @param {string} hyperlink - The hyperlink to set or undefined to clear.\n    * @param {boolean} [internal] - The flag to force hyperlink to be internal. If true, then autodetect is skipped.\n    * @returns {Sheet} The sheet.\n    */\n    /**\n    * Set the hyperlink on the cell with the given address. If opts is a Cell an internal hyperlink is added.\n    * @param {string} address - The address of the hyperlinked cell.\n    * @param {object|Cell} opts - Options.\n    * @returns {Sheet} The sheet.\n    * @ignore\n    */\n    /**\n    * Set the hyperlink on the cell with the given address and options.\n    * @param {string} address - The address of the hyperlinked cell.\n    * @param {{}|Cell} opts - Options or Cell. If opts is a Cell then an internal hyperlink is added.\n    * @param {string|Cell} [opts.hyperlink] - The hyperlink to set, can be a Cell or an internal/external string.\n    * @param {string} [opts.tooltip] - Additional text to help the user understand more about the hyperlink.\n    * @param {string} [opts.email] - Email address, ignored if opts.hyperlink is set.\n    * @param {string} [opts.emailSubject] - Email subject, ignored if opts.hyperlink is set.\n    * @returns {Sheet} The sheet.\n    */\n  }, {\n    key: \"hyperlink\",\n    value: function hyperlink() {\n      var _this12 = this;\n      return new ArgHandler('Sheet.hyperlink').case('string', function (address) {\n        var hyperlinkNode = _this12._hyperlinks[address];\n        if (!hyperlinkNode) return;\n        var relationship = _this12._relationships.findById(hyperlinkNode.attributes['r:id']);\n        return relationship && relationship.attributes.Target;\n      }).case(['string', 'nil'], function (address) {\n        // TODO: delete relationship\n        delete _this12._hyperlinks[address];\n        return _this12;\n      }).case(['string', 'string'], function (address, hyperlink) {\n        return _this12.hyperlink(address, hyperlink, false);\n      }).case(['string', 'string', 'boolean'], function (address, hyperlink, internal) {\n        var isHyperlinkInternalAddress = internal || addressConverter.fromAddress(hyperlink);\n        var nodeAttributes;\n        if (isHyperlinkInternalAddress) {\n          nodeAttributes = {\n            ref: address,\n            location: hyperlink,\n            display: hyperlink\n          };\n        } else {\n          var relationship = _this12._relationships.add(\"hyperlink\", hyperlink, \"External\");\n          nodeAttributes = {\n            ref: address,\n            'r:id': relationship.attributes.Id\n          };\n        }\n        _this12._hyperlinks[address] = {\n          name: 'hyperlink',\n          attributes: nodeAttributes,\n          children: []\n        };\n        return _this12;\n      }).case(['string', 'object'], function (address, opts) {\n        if (opts instanceof Cell) {\n          var cell = opts;\n          var hyperlink = cell.address({\n            includeSheetName: true\n          });\n          _this12.hyperlink(address, hyperlink, true);\n        } else if (opts.hyperlink) {\n          _this12.hyperlink(address, opts.hyperlink);\n        } else if (opts.email) {\n          var email = opts.email;\n          var subject = opts.emailSubject || '';\n          _this12.hyperlink(address, encodeURI(\"mailto:\".concat(email, \"?subject=\").concat(subject)));\n        }\n        var hyperlinkNode = _this12._hyperlinks[address];\n        if (hyperlinkNode) {\n          if (opts.tooltip) {\n            hyperlinkNode.attributes.tooltip = opts.tooltip;\n          }\n        }\n        return _this12;\n      }).handle(arguments);\n    }\n    /**\n     * Increment and return the max shared formula ID.\n     * @returns {number} The new max shared formula ID.\n     * @ignore\n     */\n  }, {\n    key: \"incrementMaxSharedFormulaId\",\n    value: function incrementMaxSharedFormulaId() {\n      return ++this._maxSharedFormulaId;\n    }\n    /**\n     * Get a value indicating whether the cells in the given address are merged.\n     * @param {string} address - The address to check.\n     * @returns {boolean} True if merged, false if not merged.\n     * @ignore\n     */\n    /**\n    * Merge/unmerge cells by adding/removing a mergeCell entry.\n    * @param {string} address - The address to merge.\n    * @param {boolean} merged - True to merge, false to unmerge.\n    * @returns {Sheet} The sheet.\n    * @ignore\n    */\n  }, {\n    key: \"merged\",\n    value: function merged() {\n      var _this13 = this;\n      return new ArgHandler('Sheet.merge').case('string', function (address) {\n        return _this13._mergeCells.hasOwnProperty(address);\n      }).case(['string', '*'], function (address, merge) {\n        if (merge) {\n          _this13._mergeCells[address] = {\n            name: 'mergeCell',\n            attributes: {\n              ref: address\n            },\n            children: []\n          };\n        } else {\n          delete _this13._mergeCells[address];\n        }\n        return _this13;\n      }).handle(arguments);\n    }\n    /**\n     * Gets a Object or undefined of the cells in the given address.\n     * @param {string} address - The address to check.\n     * @returns {object|boolean} Object or false if not set\n     * @ignore\n     */\n    /**\n    * Removes dataValidation at the given address\n    * @param {string} address - The address to remove.\n    * @param {boolean} obj - false to delete.\n    * @returns {boolean} true if removed.\n    * @ignore\n    */\n    /**\n    * Add dataValidation to cells at the given address if object or string\n    * @param {string} address - The address to set.\n    * @param {object|string} obj - Object or String to set\n    * @returns {Sheet} The sheet.\n    * @ignore\n    */\n  }, {\n    key: \"dataValidation\",\n    value: function dataValidation() {\n      var _this14 = this;\n      return new ArgHandler('Sheet.dataValidation').case('string', function (address) {\n        if (_this14._dataValidations[address]) {\n          return {\n            type: _this14._dataValidations[address].attributes.type,\n            allowBlank: _this14._dataValidations[address].attributes.allowBlank,\n            showInputMessage: _this14._dataValidations[address].attributes.showInputMessage,\n            prompt: _this14._dataValidations[address].attributes.prompt,\n            promptTitle: _this14._dataValidations[address].attributes.promptTitle,\n            showErrorMessage: _this14._dataValidations[address].attributes.showErrorMessage,\n            error: _this14._dataValidations[address].attributes.error,\n            errorTitle: _this14._dataValidations[address].attributes.errorTitle,\n            operator: _this14._dataValidations[address].attributes.operator,\n            formula1: _this14._dataValidations[address].children[0].children[0],\n            formula2: _this14._dataValidations[address].children[1] ? _this14._dataValidations[address].children[1].children[0] : undefined\n          };\n        } else {\n          return false;\n        }\n      }).case(['string', 'boolean'], function (address, obj) {\n        if (_this14._dataValidations[address]) {\n          if (obj === false) return delete _this14._dataValidations[address];\n        } else {\n          return false;\n        }\n      }).case(['string', '*'], function (address, obj) {\n        if (typeof obj === 'string') {\n          _this14._dataValidations[address] = {\n            name: 'dataValidation',\n            attributes: {\n              type: 'list',\n              allowBlank: false,\n              showInputMessage: false,\n              prompt: '',\n              promptTitle: '',\n              showErrorMessage: false,\n              error: '',\n              errorTitle: '',\n              operator: '',\n              sqref: address\n            },\n            children: [{\n              name: 'formula1',\n              atrributes: {},\n              children: [obj]\n            }, {\n              name: 'formula2',\n              atrributes: {},\n              children: ['']\n            }]\n          };\n        } else if (typeof obj === 'object') {\n          _this14._dataValidations[address] = {\n            name: 'dataValidation',\n            attributes: {\n              type: obj.type ? obj.type : 'list',\n              allowBlank: obj.allowBlank,\n              showInputMessage: obj.showInputMessage,\n              prompt: obj.prompt,\n              promptTitle: obj.promptTitle,\n              showErrorMessage: obj.showErrorMessage,\n              error: obj.error,\n              errorTitle: obj.errorTitle,\n              operator: obj.operator,\n              sqref: address\n            },\n            children: [{\n              name: 'formula1',\n              atrributes: {},\n              children: [obj.formula1]\n            }, {\n              name: 'formula2',\n              atrributes: {},\n              children: [obj.formula2]\n            }]\n          };\n        }\n        return _this14;\n      }).handle(arguments);\n    }\n    /**\n     * Convert the sheet to a collection of XML objects.\n     * @returns {{}} The XML forms.\n     * @ignore\n     */\n  }, {\n    key: \"toXmls\",\n    value: function toXmls() {\n      var _this15 = this;\n      // Shallow clone the node so we don't have to remove these children later if they don't belong.\n      var node = _.clone(this._node);\n      node.children = node.children.slice();\n\n      // Add the columns if needed.\n      this._colsNode.children = _.filter(this._colNodes, function (colNode, i) {\n        // Columns should only be present if they have attributes other than min/max.\n        return colNode && i === colNode.attributes.min && Object.keys(colNode.attributes).length > 2;\n      });\n      if (this._colsNode.children.length) {\n        xmlq.insertInOrder(node, this._colsNode, nodeOrder);\n      }\n\n      // Add the hyperlinks if needed.\n      this._hyperlinksNode.children = _.values(this._hyperlinks);\n      if (this._hyperlinksNode.children.length) {\n        xmlq.insertInOrder(node, this._hyperlinksNode, nodeOrder);\n      }\n\n      // Add the printOptions if needed.\n      if (this._printOptionsNode) {\n        if (Object.keys(this._printOptionsNode.attributes).length) {\n          xmlq.insertInOrder(node, this._printOptionsNode, nodeOrder);\n        }\n      }\n\n      // Add the pageMargins if needed.\n      if (this._pageMarginsNode && this._pageMarginsPresetName) {\n        // Clone to preserve the current state of this sheet.\n        var childNode = _.clone(this._pageMarginsNode);\n        if (Object.keys(this._pageMarginsNode.attributes).length) {\n          // Fill in any missing attribute values with presets.\n          childNode.attributes = _.assign(this._pageMarginsPresets[this._pageMarginsPresetName], this._pageMarginsNode.attributes);\n        } else {\n          // No need to fill in, all attributes is currently empty, simply replace.\n          childNode.attributes = this._pageMarginsPresets[this._pageMarginsPresetName];\n        }\n        xmlq.insertInOrder(node, childNode, nodeOrder);\n      }\n\n      // Add the merge cells if needed.\n      this._mergeCellsNode.children = _.values(this._mergeCells);\n      if (this._mergeCellsNode.children.length) {\n        xmlq.insertInOrder(node, this._mergeCellsNode, nodeOrder);\n      }\n\n      // Add the DataValidation cells if needed.\n      this._dataValidationsNode.children = _.values(this._dataValidations);\n      if (this._dataValidationsNode.children.length) {\n        xmlq.insertInOrder(node, this._dataValidationsNode, nodeOrder);\n      }\n      if (this._autoFilter) {\n        xmlq.insertInOrder(node, {\n          name: \"autoFilter\",\n          children: [],\n          attributes: {\n            ref: this._autoFilter.address()\n          }\n        }, nodeOrder);\n      }\n\n      // Add the PageBreaks nodes if needed.\n      ['colBreaks', 'rowBreaks'].forEach(function (name) {\n        var breaks = _this15[\"_\".concat(name, \"Node\")];\n        if (breaks.attributes.count) {\n          xmlq.insertInOrder(node, breaks, nodeOrder);\n        }\n      });\n      return {\n        id: this._idNode,\n        sheet: node,\n        relationships: this._relationships\n      };\n    }\n    /**\n     * Update the max shared formula ID to the given value if greater than current.\n     * @param {number} sharedFormulaId - The new shared formula ID.\n     * @returns {undefined}\n     * @ignore\n     */\n  }, {\n    key: \"updateMaxSharedFormulaId\",\n    value: function updateMaxSharedFormulaId(sharedFormulaId) {\n      if (sharedFormulaId > this._maxSharedFormulaId) {\n        this._maxSharedFormulaId = sharedFormulaId;\n      }\n    }\n    /**\n     * Get the print option given a valid print option attribute.\n     * @param {string} attributeName - Attribute name of the printOptions.\n     *   gridLines - Used in conjunction with gridLinesSet. If both gridLines and gridlinesSet are true, then grid lines shall print. Otherwise, they shall not (i.e., one or both have false values).\n     *   gridLinesSet - Used in conjunction with gridLines. If both gridLines and gridLinesSet are true, then grid lines shall print. Otherwise, they shall not (i.e., one or both have false values).\n     *   headings - Print row and column headings.\n     *   horizontalCentered - Center on page horizontally when printing.\n     *   verticalCentered - Center on page vertically when printing.\n     * @returns {boolean}\n     */\n    /**\n    * Set the print option given a valid print option attribute and a value.\n    * @param {string} attributeName - Attribute name of the printOptions. See get print option for list of valid attributes.\n    * @param {undefined|boolean} attributeEnabled - If `undefined` or `false` then the attribute is removed, otherwise the print option is enabled.\n    * @returns {Sheet} The sheet.\n    */\n  }, {\n    key: \"printOptions\",\n    value: function printOptions() {\n      var _this16 = this;\n      var supportedAttributeNames = ['gridLines', 'gridLinesSet', 'headings', 'horizontalCentered', 'verticalCentered'];\n      var checkAttributeName = this._getCheckAttributeNameHelper('printOptions', supportedAttributeNames);\n      return new ArgHandler('Sheet.printOptions').case(['string'], function (attributeName) {\n        checkAttributeName(attributeName);\n        return _this16._printOptionsNode.attributes[attributeName] === 1;\n      }).case(['string', 'nil'], function (attributeName) {\n        checkAttributeName(attributeName);\n        delete _this16._printOptionsNode.attributes[attributeName];\n        return _this16;\n      }).case(['string', 'boolean'], function (attributeName, attributeEnabled) {\n        checkAttributeName(attributeName);\n        if (attributeEnabled) {\n          _this16._printOptionsNode.attributes[attributeName] = 1;\n          return _this16;\n        } else {\n          return _this16.printOptions(attributeName, undefined);\n        }\n      }).handle(arguments);\n    }\n    /**\n     * Get the print option for the gridLines attribute value.\n     * @returns {boolean}\n     */\n    /**\n    * Set the print option for the gridLines attribute value.\n    * @param {undefined|boolean} enabled - If `undefined` or `false` then attribute is removed, otherwise gridLines is enabled.\n    * @returns {Sheet} The sheet.\n    */\n  }, {\n    key: \"printGridLines\",\n    value: function printGridLines() {\n      var _this17 = this;\n      return new ArgHandler('Sheet.gridLines').case(function () {\n        return _this17.printOptions('gridLines') && _this17.printOptions('gridLinesSet');\n      }).case(['nil'], function () {\n        _this17.printOptions('gridLines', undefined);\n        _this17.printOptions('gridLinesSet', undefined);\n        return _this17;\n      }).case(['boolean'], function (enabled) {\n        _this17.printOptions('gridLines', enabled);\n        _this17.printOptions('gridLinesSet', enabled);\n        return _this17;\n      }).handle(arguments);\n    }\n    /**\n     * Get the page margin given a valid attribute name.\n     * If the value is not yet defined, then it will return the current preset value.\n     * @param {string} attributeName - Attribute name of the pageMargins.\n     *     left - Left Page Margin in inches.\n     *     right - Right page margin in inches.\n     *     top - Top Page Margin in inches.\n     *     buttom - Bottom Page Margin in inches.\n     *     footer - Footer Page Margin in inches.\n     *     header - Header Page Margin in inches.\n     * @returns {number} the attribute value.\n     */\n    /**\n    * Set the page margin (or override the preset) given an attribute name and a value.\n    * @param {string} attributeName - Attribute name of the pageMargins. See get page margin for list of valid attributes.\n    * @param {undefined|number|string} attributeStringValue - If `undefined` then set back to preset value, otherwise, set the given attribute value.\n    * @returns {Sheet} The sheet.\n    */\n  }, {\n    key: \"pageMargins\",\n    value: function pageMargins() {\n      var _this18 = this;\n      if (this.pageMarginsPreset() === undefined) {\n        throw new Error('Sheet.pageMargins: preset is undefined.');\n      }\n      var supportedAttributeNames = ['left', 'right', 'top', 'bottom', 'header', 'footer'];\n      var checkAttributeName = this._getCheckAttributeNameHelper('pageMargins', supportedAttributeNames);\n      var checkRange = this._getCheckRangeHelper('pageMargins', 0, undefined);\n      return new ArgHandler('Sheet.pageMargins').case(['string'], function (attributeName) {\n        checkAttributeName(attributeName);\n        var attributeValue = _this18._pageMarginsNode.attributes[attributeName];\n        if (attributeValue !== undefined) {\n          return parseFloat(attributeValue);\n        } else if (_this18._pageMarginsPresetName) {\n          return parseFloat(_this18._pageMarginsPresets[_this18._pageMarginsPresetName][attributeName]);\n        } else {\n          return undefined;\n        }\n      }).case(['string', 'nil'], function (attributeName) {\n        checkAttributeName(attributeName);\n        delete _this18._pageMarginsNode.attributes[attributeName];\n        return _this18;\n      }).case(['string', 'number'], function (attributeName, attributeNumberValue) {\n        checkAttributeName(attributeName);\n        checkRange(attributeNumberValue);\n        _this18._pageMarginsNode.attributes[attributeName] = attributeNumberValue;\n        return _this18;\n      }).case(['string', 'string'], function (attributeName, attributeStringValue) {\n        return _this18.pageMargins(attributeName, parseFloat(attributeStringValue));\n      }).handle(arguments);\n    }\n    /**\n     * Page margins preset is a set of page margins associated with a name.\n     * The page margin preset acts as a fallback when not explicitly defined by `Sheet.pageMargins`.\n     * If a sheet already contains page margins, it attempts to auto-detect, otherwise they are defined as the template preset.\n     * If no page margins exist, then the preset is undefined and will not be included in the output of `Sheet.toXmls`.\n     * Available presets include: normal, wide, narrow, template.\n     *\n     * Get the page margins preset name. The registered name of a predefined set of attributes.\n     * @returns {string} The preset name.\n     */\n    /**\n    * Set the page margins preset by name, clearing any existing/temporary attribute values.\n    * @param {undefined|string} presetName - The preset name. If `undefined`, page margins will not be included in the output of `Sheet.toXmls`.\n    * @returns {Sheet} The sheet.\n    */\n    /**\n    * Set a new page margins preset by name and attributes object.\n    * @param {string} presetName - The preset name.\n    * @param {object} presetAttributes - The preset attributes.\n    * @returns {Sheet} The sheet.\n    */\n  }, {\n    key: \"pageMarginsPreset\",\n    value: function pageMarginsPreset() {\n      var _this19 = this;\n      return new ArgHandler('Sheet.pageMarginsPreset').case(function () {\n        return _this19._pageMarginsPresetName;\n      }).case(['nil'], function () {\n        // Remove all preset overrides and exclude from sheet\n        _this19._pageMarginsPresetName = undefined;\n\n        // Remove all preset overrides\n        _this19._pageMarginsNode.attributes = {};\n        return _this19;\n      }).case(['string'], function (presetName) {\n        var checkPresetName = _this19._getCheckAttributeNameHelper('pageMarginsPreset', Object.keys(_this19._pageMarginsPresets));\n        checkPresetName(presetName);\n\n        // Change to new preset\n        _this19._pageMarginsPresetName = presetName;\n\n        // Remove all preset overrides\n        _this19._pageMarginsNode.attributes = {};\n        return _this19;\n      }).case(['string', 'object'], function (presetName, presetAttributes) {\n        if (_this19._pageMarginsPresets.hasOwnProperty(presetName)) {\n          throw new Error(\"Sheet.pageMarginsPreset: The preset \".concat(presetName, \" already exists!\"));\n        }\n\n        // Validate preset attribute keys.\n        var pageMarginsAttributeNames = ['left', 'right', 'top', 'bottom', 'header', 'footer'];\n        var isValidPresetAttributeKeys = _.isEqual(_.sortBy(pageMarginsAttributeNames), _.sortBy(Object.keys(presetAttributes)));\n        if (isValidPresetAttributeKeys === false) {\n          throw new Error(\"Sheet.pageMarginsPreset: Invalid preset attributes for one or key(s)! - \\\"\".concat(Object.keys(presetAttributes), \"\\\"\"));\n        }\n\n        // Validate preset attribute values.\n        _.forEach(function (attributeValue, attributeName) {\n          var attributeNumberValue = parseFloat(attributeValue);\n          if (_.isNaN(attributeNumberValue) || _.isNumber(attributeNumberValue) === false) {\n            throw new Error(\"Sheet.pageMarginsPreset: Invalid preset attribute value! - \\\"\".concat(attributeValue, \"\\\"\"));\n          }\n        });\n\n        // Change to new preset\n        _this19._pageMarginsPresetName = presetName;\n\n        // Remove all preset overrides\n        _this19._pageMarginsNode.attributes = {};\n\n        // Register the preset\n        _this19._pageMarginsPresets[presetName] = presetAttributes;\n        return _this19;\n      }).handle(arguments);\n    }\n    /**\n     * https://docs.microsoft.com/en-us/dotnet/api/documentformat.openxml.spreadsheet.pane?view=openxml-2.8.1\n     * @typedef {Object} PaneOptions\n     * @property {string} activePane=bottomRight Active Pane. The pane that is active.\n     * @property {string} state Split State. Indicates whether the pane has horizontal / vertical splits,\n     * and whether those splits are frozen.\n     * @property {string} topLeftCell Top Left Visible Cell. Location of the top left visible cell in the bottom\n     * right pane (when in Left-To-Right mode).\n     * @property {number} xSplit (Horizontal Split Position) Horizontal position of the split, in 1/20th of a point;\n     * 0 (zero) if none. If the pane is frozen, this value indicates the number of columns visible in the top pane.\n     * @property {number} ySplit (Vertical Split Position) Vertical position of the split, in 1/20th of a point; 0\n     * (zero) if none. If the pane is frozen, this value indicates the number of rows visible in the left pane.\n     */\n    /**\n    * Gets sheet view pane options\n    * @return {PaneOptions} sheet view pane options\n    */\n    /**\n    * Sets sheet view pane options\n    * @param {PaneOptions|null|undefined} paneOptions sheet view pane options\n    * @return {Sheet} The sheet\n    */\n  }, {\n    key: \"panes\",\n    value: function panes() {\n      var _this20 = this;\n      var supportedStates = ['split', 'frozen', 'frozenSplit'];\n      var supportedActivePanes = ['bottomLeft', 'bottomRight', 'topLeft', 'topRight'];\n      var checkStateName = this._getCheckAttributeNameHelper('pane.state', supportedStates);\n      var checkActivePane = this._getCheckAttributeNameHelper('pane.activePane', supportedActivePanes);\n      var sheetViewNode = this._getOrCreateSheetViewNode();\n      var paneNode = xmlq.findChild(sheetViewNode, 'pane');\n      return new ArgHandler('Sheet.pane').case(function () {\n        if (paneNode) {\n          var result = _.cloneDeep(paneNode.attributes);\n          if (!result.state) result.state = 'split';\n          return result;\n        }\n      }).case(['nil'], function () {\n        xmlq.removeChild(sheetViewNode, 'pane');\n        return _this20;\n      }).case(['object'], function (paneAttributes) {\n        var attributes = _.assign({\n          activePane: 'bottomRight'\n        }, paneAttributes);\n        checkStateName(attributes.state);\n        checkActivePane(attributes.activePane);\n        if (paneNode) {\n          paneNode.attributes = attributes;\n        } else {\n          paneNode = {\n            name: \"pane\",\n            attributes: attributes,\n            children: []\n          };\n          xmlq.appendChild(sheetViewNode, paneNode);\n        }\n        return _this20;\n      }).handle(arguments);\n    }\n    /**\n     * Freezes Panes for this sheet.\n     * @param {number} xSplit the number of columns visible in the top pane. 0 (zero) if none.\n     * @param {number} ySplit the number of rows visible in the left pane. 0 (zero) if none.\n     * @return {Sheet} The sheet\n     */\n    /**\n    * freezes Panes for this sheet.\n    * @param {string} topLeftCell Top Left Visible Cell. Location of the top left visible cell in the bottom\n    * right pane (when in Left-To-Right mode).\n    * @return {Sheet} The sheet\n    */\n  }, {\n    key: \"freezePanes\",\n    value: function freezePanes() {\n      var _this21 = this;\n      return new ArgHandler('Sheet.feezePanes').case(['integer', 'integer'], function (xSplit, ySplit) {\n        var topLeftCell = addressConverter.columnNumberToName(xSplit + 1) + (ySplit + 1);\n        var activePane = xSplit === 0 ? 'bottomLeft' : 'bottomRight';\n        activePane = ySplit === 0 ? 'topRight' : activePane;\n        return _this21.panes({\n          state: 'frozen',\n          topLeftCell: topLeftCell,\n          xSplit: xSplit,\n          ySplit: ySplit,\n          activePane: activePane\n        });\n      }).case(['string'], function (topLeftCell) {\n        var ref = addressConverter.fromAddress(topLeftCell);\n        var xSplit = ref.columnNumber - 1,\n          ySplit = ref.rowNumber - 1;\n        var activePane = xSplit === 0 ? 'bottomLeft' : 'bottomRight';\n        activePane = ySplit === 0 ? 'topRight' : activePane;\n        return _this21.panes({\n          state: 'frozen',\n          topLeftCell: topLeftCell,\n          xSplit: xSplit,\n          ySplit: ySplit,\n          activePane: activePane\n        });\n      }).handle(arguments);\n    }\n    /**\n     * Splits Panes for this sheet.\n     * @param {number} xSplit (Horizontal Split Position) Horizontal position of the split,\n     * in 1/20th of a point; 0 (zero) if none.\n     * @param {number} ySplit (Vertical Split Position) VVertical position of the split,\n     * in 1/20th of a point; 0 (zero) if none.\n     * @return {Sheet} The sheet\n     */\n  }, {\n    key: \"splitPanes\",\n    value: function splitPanes(xSplit, ySplit) {\n      return this.panes({\n        state: 'split',\n        xSplit: xSplit,\n        ySplit: ySplit\n      });\n    }\n    /**\n     * resets to default sheet view panes.\n     * @return {Sheet} The sheet\n     */\n  }, {\n    key: \"resetPanes\",\n    value: function resetPanes() {\n      return this.panes(null);\n    }\n    /* PRIVATE */\n    /**\n     * Get a helper function to check that the attribute name provided is supported.\n     * @param {string} functionName - Name of the parent function.\n     * @param {array} supportedAttributeNames - Array of supported attribute name strings.\n     * @returns {function} The helper function, which takes an attribute name. If the array of supported attribute names does not contain the given attribute name, then an Error is thrown.\n     * @ignore\n     */\n  }, {\n    key: \"_getCheckAttributeNameHelper\",\n    value: function _getCheckAttributeNameHelper(functionName, supportedAttributeNames) {\n      return function (attributeName) {\n        if (!_.includes(supportedAttributeNames, attributeName)) {\n          throw new Error(\"Sheet.\".concat(functionName, \": \\\"\").concat(attributeName, \"\\\" is not supported.\"));\n        }\n      };\n    }\n    /**\n     * Get a helper function to check that the value is of the expected type.\n     * @param {string} functionName - Name of the parent function.\n     * @param {string} valueType - A string produced by typeof.\n     * @returns {function} The helper function, which takes a value. If the value type is not expected, a TypeError is thrown.\n     * @ignore\n     */\n  }, {\n    key: \"_getCheckTypeHelper\",\n    value: function _getCheckTypeHelper(functionName, valueType) {\n      return function (value) {\n        if (typeof value !== valueType) {\n          throw new TypeError(\"Sheet.\".concat(functionName, \": invalid type - value must be of type \").concat(valueType, \".\"));\n        }\n      };\n    }\n    /**\n     * Get a helper function to check that the value is within the expected range.\n     * @param {string} functionName - Name of the parent function.\n     * @param {undefined|number} valueMin - The minimum value of the range. This value is range-inclusive.\n     * @param {undefined|number} valueMax - The maximum value of the range. This value is range-exclusive.\n     * @returns {function} The helper function, which takes a value. If the value type is not 'number', a TypeError is thrown. If the value is not within the range, a RangeError is thrown.\n     * @ignore\n     */\n  }, {\n    key: \"_getCheckRangeHelper\",\n    value: function _getCheckRangeHelper(functionName, valueMin, valueMax) {\n      var checkType = this._getCheckTypeHelper(functionName, 'number');\n      return function (value) {\n        checkType(value);\n        if (valueMin !== undefined) {\n          if (value < valueMin) {\n            throw new RangeError(\"Sheet.\".concat(functionName, \": value too small - value must be greater than or equal to \").concat(valueMin, \".\"));\n          }\n        }\n        if (valueMax !== undefined) {\n          if (valueMax <= value) {\n            throw new RangeError(\"Sheet.\".concat(functionName, \": value too large - value must be less than \").concat(valueMax, \".\"));\n          }\n        }\n      };\n    }\n    /**\n     * Get the sheet view node if it exists or create it if it doesn't.\n     * @returns {{}} The sheet view node.\n     * @private\n     */\n  }, {\n    key: \"_getOrCreateSheetViewNode\",\n    value: function _getOrCreateSheetViewNode() {\n      var sheetViewsNode = xmlq.findChild(this._node, \"sheetViews\");\n      if (!sheetViewsNode) {\n        sheetViewsNode = {\n          name: \"sheetViews\",\n          attributes: {},\n          children: [{\n            name: \"sheetView\",\n            attributes: {\n              workbookViewId: 0\n            },\n            children: []\n          }]\n        };\n        xmlq.insertInOrder(this._node, sheetViewsNode, nodeOrder);\n      }\n      return xmlq.findChild(sheetViewsNode, \"sheetView\");\n    }\n    /**\n     * Initializes the sheet.\n     * @param {Workbook} workbook - The parent workbook.\n     * @param {{}} idNode - The sheet ID node (from the parent workbook).\n     * @param {{}} node - The sheet node.\n     * @param {{}} [relationshipsNode] - The optional sheet relationships node.\n     * @returns {undefined}\n     * @private\n     */\n  }, {\n    key: \"_init\",\n    value: function _init(workbook, idNode, node, relationshipsNode) {\n      var _this22 = this;\n      if (!node) {\n        node = {\n          name: \"worksheet\",\n          attributes: {\n            xmlns: \"http://schemas.openxmlformats.org/spreadsheetml/2006/main\",\n            'xmlns:r': \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\",\n            'xmlns:mc': \"http://schemas.openxmlformats.org/markup-compatibility/2006\",\n            'mc:Ignorable': \"x14ac\",\n            'xmlns:x14ac': \"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\"\n          },\n          children: [{\n            name: \"sheetData\",\n            attributes: {},\n            children: []\n          }]\n        };\n      }\n      this._workbook = workbook;\n      this._idNode = idNode;\n      this._node = node;\n      this._maxSharedFormulaId = -1;\n      this._mergeCells = {};\n      this._dataValidations = {};\n      this._hyperlinks = {};\n      this._autoFilter = null;\n\n      // Create the relationships.\n      this._relationships = new Relationships(relationshipsNode);\n\n      // Delete the optional dimension node\n      xmlq.removeChild(this._node, \"dimension\");\n\n      // Create the rows.\n      this._rows = [];\n      this._sheetDataNode = xmlq.findChild(this._node, \"sheetData\");\n      this._sheetDataNode.children.forEach(function (rowNode) {\n        var row = new Row(_this22, rowNode);\n        _this22._rows[row.rowNumber()] = row;\n      });\n      this._sheetDataNode.children = this._rows;\n\n      // Create the columns node.\n      this._columns = [];\n      this._colsNode = xmlq.findChild(this._node, \"cols\");\n      if (this._colsNode) {\n        xmlq.removeChild(this._node, this._colsNode);\n      } else {\n        this._colsNode = {\n          name: 'cols',\n          attributes: {},\n          children: []\n        };\n      }\n\n      // Cache the col nodes.\n      this._colNodes = [];\n      _.forEach(this._colsNode.children, function (colNode) {\n        var min = colNode.attributes.min;\n        var max = colNode.attributes.max;\n        for (var i = min; i <= max; i++) {\n          _this22._colNodes[i] = colNode;\n        }\n      });\n\n      // Create the sheet properties node.\n      this._sheetPrNode = xmlq.findChild(this._node, \"sheetPr\");\n      if (!this._sheetPrNode) {\n        this._sheetPrNode = {\n          name: 'sheetPr',\n          attributes: {},\n          children: []\n        };\n        xmlq.insertInOrder(this._node, this._sheetPrNode, nodeOrder);\n      }\n\n      // Create the merge cells.\n      this._mergeCellsNode = xmlq.findChild(this._node, \"mergeCells\");\n      if (this._mergeCellsNode) {\n        xmlq.removeChild(this._node, this._mergeCellsNode);\n      } else {\n        this._mergeCellsNode = {\n          name: 'mergeCells',\n          attributes: {},\n          children: []\n        };\n      }\n      var mergeCellNodes = this._mergeCellsNode.children;\n      this._mergeCellsNode.children = [];\n      mergeCellNodes.forEach(function (mergeCellNode) {\n        _this22._mergeCells[mergeCellNode.attributes.ref] = mergeCellNode;\n      });\n\n      // Create the DataValidations.\n      this._dataValidationsNode = xmlq.findChild(this._node, \"dataValidations\");\n      if (this._dataValidationsNode) {\n        xmlq.removeChild(this._node, this._dataValidationsNode);\n      } else {\n        this._dataValidationsNode = {\n          name: 'dataValidations',\n          attributes: {},\n          children: []\n        };\n      }\n      var dataValidationNodes = this._dataValidationsNode.children;\n      this._dataValidationsNode.children = [];\n      dataValidationNodes.forEach(function (dataValidationNode) {\n        _this22._dataValidations[dataValidationNode.attributes.sqref] = dataValidationNode;\n      });\n\n      // Create the hyperlinks.\n      this._hyperlinksNode = xmlq.findChild(this._node, \"hyperlinks\");\n      if (this._hyperlinksNode) {\n        xmlq.removeChild(this._node, this._hyperlinksNode);\n      } else {\n        this._hyperlinksNode = {\n          name: 'hyperlinks',\n          attributes: {},\n          children: []\n        };\n      }\n      var hyperlinkNodes = this._hyperlinksNode.children;\n      this._hyperlinksNode.children = [];\n      hyperlinkNodes.forEach(function (hyperlinkNode) {\n        _this22._hyperlinks[hyperlinkNode.attributes.ref] = hyperlinkNode;\n      });\n\n      // Create the printOptions.\n      this._printOptionsNode = xmlq.findChild(this._node, \"printOptions\");\n      if (this._printOptionsNode) {\n        xmlq.removeChild(this._node, this._printOptionsNode);\n      } else {\n        this._printOptionsNode = {\n          name: 'printOptions',\n          attributes: {},\n          children: []\n        };\n      }\n\n      // Create the pageMargins.\n      this._pageMarginsPresets = {\n        normal: {\n          left: 0.7,\n          right: 0.7,\n          top: 0.75,\n          bottom: 0.75,\n          header: 0.3,\n          footer: 0.3\n        },\n        wide: {\n          left: 1,\n          right: 1,\n          top: 1,\n          bottom: 1,\n          header: 0.5,\n          footer: 0.5\n        },\n        narrow: {\n          left: 0.25,\n          right: 0.25,\n          top: 0.75,\n          bottom: 0.75,\n          header: 0.3,\n          footer: 0.3\n        }\n      };\n      this._pageMarginsNode = xmlq.findChild(this._node, \"pageMargins\");\n      if (this._pageMarginsNode) {\n        // Sheet has page margins, assume preset is template.\n        this._pageMarginsPresetName = 'template';\n\n        // Search for a preset that matches existing attributes.\n        for (var presetName in this._pageMarginsPresets) {\n          if (_.isEqual(this._pageMarginsNode.attributes, this._pageMarginsPresets[presetName])) {\n            this._pageMarginsPresetName = presetName;\n            break;\n          }\n        }\n\n        // If template preset, then register as template preset, and clear attributes.\n        if (this._pageMarginsPresetName === 'template') {\n          this._pageMarginsPresets.template = this._pageMarginsNode.attributes;\n          this._pageMarginsNode.attributes = {};\n        }\n        xmlq.removeChild(this._node, this._pageMarginsNode);\n      } else {\n        // Sheet has no page margins, the preset assignment is therefore undefined.\n        this._pageMarginsPresetName = undefined;\n        this._pageMarginsNode = {\n          name: 'pageMargins',\n          attributes: {},\n          children: []\n        };\n      }\n\n      // Create the pageBreaks\n      ['colBreaks', 'rowBreaks'].forEach(function (name) {\n        _this22[\"_\".concat(name, \"Node\")] = xmlq.findChild(_this22._node, name);\n        if (_this22[\"_\".concat(name, \"Node\")]) {\n          xmlq.removeChild(_this22._node, _this22[\"_\".concat(name, \"Node\")]);\n        } else {\n          _this22[\"_\".concat(name, \"Node\")] = {\n            name: name,\n            children: [],\n            attributes: {\n              count: 0,\n              manualBreakCount: 0\n            }\n          };\n        }\n      });\n      this._pageBreaks = {\n        colBreaks: new PageBreaks(this._colBreaksNode),\n        rowBreaks: new PageBreaks(this._rowBreaksNode)\n      };\n    }\n  }]);\n  return Sheet;\n}();\nmodule.exports = Sheet;\n\n/*\nxl/workbook.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<worksheet ...>\n    ...\n\n    <printOptions headings=\"1\" gridLines=\"1\" />\n    <pageMargins left=\"0.7\" right=\"0.7\" top=\"0.75\" bottom=\"0.75\" header=\"0.3\" footer=\"0.3\" />\n    <pageSetup orientation=\"portrait\" horizontalDpi=\"0\" verticalDpi=\"0\" />\n</worksheet>\n// */","map":null,"metadata":{},"sourceType":"script"}
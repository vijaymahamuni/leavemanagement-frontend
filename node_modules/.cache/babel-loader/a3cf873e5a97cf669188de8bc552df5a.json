{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Project\\\\Front_end\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Project\\\\Front_end\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _ = require(\"lodash\");\nvar ArgHandler = require(\"./ArgHandler\");\nvar addressConverter = require(\"./addressConverter\");\nvar dateConverter = require(\"./dateConverter\");\nvar regexify = require(\"./regexify\");\nvar xmlq = require(\"./xmlq\");\nvar FormulaError = require(\"./FormulaError\");\nvar Style = require(\"./Style\");\nvar RichText = require(\"./RichText\");\n\n/**\n * A cell\n */\nvar Cell = /*#__PURE__*/function () {\n  // /**\n  //  * Creates a new instance of cell.\n  //  * @param {Row} row - The parent row.\n  //  * @param {{}} node - The cell node.\n  //  */\n  function Cell(row, node, styleId) {\n    _classCallCheck(this, Cell);\n    this._row = row;\n    this._init(node, styleId);\n  }\n\n  /* PUBLIC */\n\n  /**\n   * Gets a value indicating whether the cell is the active cell in the sheet.\n   * @returns {boolean} True if active, false otherwise.\n   */ /**\n      * Make the cell the active cell in the sheet.\n      * @param {boolean} active - Must be set to `true`. Deactivating directly is not supported. To deactivate, you should activate a different cell instead.\n      * @returns {Cell} The cell.\n      */\n  _createClass(Cell, [{\n    key: \"active\",\n    value: function active() {\n      var _this = this;\n      return new ArgHandler('Cell.active').case(function () {\n        return _this.sheet().activeCell() === _this;\n      }).case('boolean', function (active) {\n        if (!active) throw new Error(\"Deactivating cell directly not supported. Activate a different cell instead.\");\n        _this.sheet().activeCell(_this);\n        return _this;\n      }).handle(arguments);\n    }\n    /**\n     * Get the address of the column.\n     * @param {{}} [opts] - Options\n     * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n     * @param {boolean} [opts.rowAnchored] - Anchor the row.\n     * @param {boolean} [opts.columnAnchored] - Anchor the column.\n     * @param {boolean} [opts.anchored] - Anchor both the row and the column.\n     * @returns {string} The address\n     */\n  }, {\n    key: \"address\",\n    value: function address(opts) {\n      return addressConverter.toAddress({\n        type: 'cell',\n        rowNumber: this.rowNumber(),\n        columnNumber: this.columnNumber(),\n        sheetName: opts && opts.includeSheetName && this.sheet().name(),\n        rowAnchored: opts && (opts.rowAnchored || opts.anchored),\n        columnAnchored: opts && (opts.columnAnchored || opts.anchored)\n      });\n    }\n    /**\n     * Gets the parent column of the cell.\n     * @returns {Column} The parent column.\n     */\n  }, {\n    key: \"column\",\n    value: function column() {\n      return this.sheet().column(this.columnNumber());\n    }\n    /**\n     * Clears the contents from the cell.\n     * @returns {Cell} The cell.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var hostSharedFormulaId = this._formulaRef && this._sharedFormulaId;\n      delete this._value;\n      delete this._formulaType;\n      delete this._formula;\n      delete this._sharedFormulaId;\n      delete this._formulaRef;\n\n      // TODO in future version: Move shared formula to some other cell. This would require parsing the formula...\n      if (!_.isNil(hostSharedFormulaId)) this.sheet().clearCellsUsingSharedFormula(hostSharedFormulaId);\n      return this;\n    }\n    /**\n     * Gets the column name of the cell.\n     * @returns {string} The column name.\n     */\n  }, {\n    key: \"columnName\",\n    value: function columnName() {\n      return addressConverter.columnNumberToName(this.columnNumber());\n    }\n    /**\n     * Gets the column number of the cell (1-based).\n     * @returns {number} The column number.\n     */\n  }, {\n    key: \"columnNumber\",\n    value: function columnNumber() {\n      return this._columnNumber;\n    }\n    /**\n     * Find the given pattern in the cell and optionally replace it.\n     * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n     * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in the cell will be replaced.\n     * @returns {boolean} A flag indicating if the pattern was found.\n     */\n  }, {\n    key: \"find\",\n    value: function find(pattern, replacement) {\n      pattern = regexify(pattern);\n      var value = this.value();\n      if (typeof value !== 'string') return false;\n      if (_.isNil(replacement)) {\n        return pattern.test(value);\n      } else {\n        var replaced = value.replace(pattern, replacement);\n        if (replaced === value) return false;\n        this.value(replaced);\n        return true;\n      }\n    }\n    /**\n     * Gets the formula in the cell. Note that if a formula was set as part of a range, the getter will return 'SHARED'. This is a limitation that may be addressed in a future release.\n     * @returns {string} The formula in the cell.\n     */\n    /**\n    * Sets the formula in the cell.\n    * @param {string} formula - The formula to set.\n    * @returns {Cell} The cell.\n    */\n  }, {\n    key: \"formula\",\n    value: function formula() {\n      var _this2 = this;\n      return new ArgHandler('Cell.formula').case(function () {\n        // TODO in future: Return translated formula.\n        if (_this2._formulaType === \"shared\" && !_this2._formulaRef) return \"SHARED\";\n        return _this2._formula;\n      }).case('nil', function () {\n        _this2.clear();\n        return _this2;\n      }).case('string', function (formula) {\n        _this2.clear();\n        _this2._formulaType = \"normal\";\n        _this2._formula = formula;\n        return _this2;\n      }).handle(arguments);\n    }\n    /**\n     * Gets the hyperlink attached to the cell.\n     * @returns {string|undefined} The hyperlink or undefined if not set.\n     */\n    /**\n    * Set or clear the hyperlink on the cell.\n    * @param {string|Cell|undefined} hyperlink - The hyperlink to set or undefined to clear.\n    * @returns {Cell} The cell.\n    */\n    /**\n    * Set the hyperlink options on the cell.\n    * @param {{}|Cell} opts - Options or Cell. If opts is a Cell then an internal hyperlink is added.\n    * @param {string|Cell} [opts.hyperlink] - The hyperlink to set, can be a Cell or an internal/external string.\n    * @param {string} [opts.tooltip] - Additional text to help the user understand more about the hyperlink.\n    * @param {string} [opts.email] - Email address, ignored if opts.hyperlink is set.\n    * @param {string} [opts.emailSubject] - Email subject, ignored if opts.hyperlink is set.\n    * @returns {Cell} The cell.\n    */\n  }, {\n    key: \"hyperlink\",\n    value: function hyperlink() {\n      var _this3 = this;\n      return new ArgHandler('Cell.hyperlink').case(function () {\n        return _this3.sheet().hyperlink(_this3.address());\n      }).case('string', function (hyperlink) {\n        _this3.sheet().hyperlink(_this3.address(), hyperlink);\n        return _this3;\n      }).case(['object'], function (opts) {\n        _this3.sheet().hyperlink(_this3.address(), opts);\n        return _this3;\n      }).handle(arguments);\n    }\n    /**\n     * Gets the data validation object attached to the cell.\n     * @returns {object|undefined} The data validation or undefined if not set.\n     */\n    /**\n    * Set or clear the data validation object of the cell.\n    * @param {object|undefined} dataValidation - Object or null to clear.\n    * @returns {Cell} The cell.\n    */\n  }, {\n    key: \"dataValidation\",\n    value: function dataValidation() {\n      var _this4 = this;\n      return new ArgHandler('Cell.dataValidation').case(function () {\n        return _this4.sheet().dataValidation(_this4.address());\n      }).case('boolean', function (obj) {\n        return _this4.sheet().dataValidation(_this4.address(), obj);\n      }).case('*', function (obj) {\n        _this4.sheet().dataValidation(_this4.address(), obj);\n        return _this4;\n      }).handle(arguments);\n    }\n    /**\n     * Callback used by tap.\n     * @callback Cell~tapCallback\n     * @param {Cell} cell - The cell\n     * @returns {undefined}\n     */\n    /**\n    * Invoke a callback on the cell and return the cell. Useful for method chaining.\n    * @param {Cell~tapCallback} callback - The callback function.\n    * @returns {Cell} The cell.\n    */\n  }, {\n    key: \"tap\",\n    value: function tap(callback) {\n      callback(this);\n      return this;\n    }\n    /**\n     * Callback used by thru.\n     * @callback Cell~thruCallback\n     * @param {Cell} cell - The cell\n     * @returns {*} The value to return from thru.\n     */\n    /**\n    * Invoke a callback on the cell and return the value provided by the callback. Useful for method chaining.\n    * @param {Cell~thruCallback} callback - The callback function.\n    * @returns {*} The return value of the callback.\n    */\n  }, {\n    key: \"thru\",\n    value: function thru(callback) {\n      return callback(this);\n    }\n    /**\n     * Create a range from this cell and another.\n     * @param {Cell|string} cell - The other cell or cell address to range to.\n     * @returns {Range} The range.\n     */\n  }, {\n    key: \"rangeTo\",\n    value: function rangeTo(cell) {\n      return this.sheet().range(this, cell);\n    }\n    /**\n     * Returns a cell with a relative position given the offsets provided.\n     * @param {number} rowOffset - The row offset (0 for the current row).\n     * @param {number} columnOffset - The column offset (0 for the current column).\n     * @returns {Cell} The relative cell.\n     */\n  }, {\n    key: \"relativeCell\",\n    value: function relativeCell(rowOffset, columnOffset) {\n      var row = rowOffset + this.rowNumber();\n      var column = columnOffset + this.columnNumber();\n      return this.sheet().cell(row, column);\n    }\n    /**\n     * Gets the parent row of the cell.\n     * @returns {Row} The parent row.\n     */\n  }, {\n    key: \"row\",\n    value: function row() {\n      return this._row;\n    }\n    /**\n     * Gets the row number of the cell (1-based).\n     * @returns {number} The row number.\n     */\n  }, {\n    key: \"rowNumber\",\n    value: function rowNumber() {\n      return this.row().rowNumber();\n    }\n    /**\n     * Gets the parent sheet.\n     * @returns {Sheet} The parent sheet.\n     */\n  }, {\n    key: \"sheet\",\n    value: function sheet() {\n      return this.row().sheet();\n    }\n    /**\n     * Gets an individual style.\n     * @param {string} name - The name of the style.\n     * @returns {*} The style.\n     */\n    /**\n    * Gets multiple styles.\n    * @param {Array.<string>} names - The names of the style.\n    * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.\n    */\n    /**\n    * Sets an individual style.\n    * @param {string} name - The name of the style.\n    * @param {*} value - The value to set.\n    * @returns {Cell} The cell.\n    */\n    /**\n    * Sets the styles in the range starting with the cell.\n    * @param {string} name - The name of the style.\n    * @param {Array.<Array.<*>>} - 2D array of values to set.\n    * @returns {Range} The range that was set.\n    */\n    /**\n    * Sets multiple styles.\n    * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.\n    * @returns {Cell} The cell.\n    */\n    /**\n    * Sets to a specific style\n    * @param {Style} style - Style object given from stylesheet.createStyle\n    * @returns {Cell} The cell.\n    */\n  }, {\n    key: \"style\",\n    value: function style() {\n      var _this5 = this;\n      if (!this._style && !(arguments[0] instanceof Style)) {\n        this._style = this.workbook().styleSheet().createStyle(this._styleId);\n      }\n      return new ArgHandler(\"Cell.style\").case('string', function (name) {\n        // Get single value\n        return _this5._style.style(name);\n      }).case('array', function (names) {\n        // Get list of values\n        var values = {};\n        names.forEach(function (name) {\n          values[name] = _this5.style(name);\n        });\n        return values;\n      }).case([\"string\", \"array\"], function (name, values) {\n        var numRows = values.length;\n        var numCols = values[0].length;\n        var range = _this5.rangeTo(_this5.relativeCell(numRows - 1, numCols - 1));\n        return range.style(name, values);\n      }).case(['string', '*'], function (name, value) {\n        // Set a single value for all cells to a single value\n        _this5._style.style(name, value);\n        return _this5;\n      }).case('object', function (nameValues) {\n        // Object of key value pairs to set\n        for (var name in nameValues) {\n          if (!nameValues.hasOwnProperty(name)) continue;\n          var value = nameValues[name];\n          _this5.style(name, value);\n        }\n        return _this5;\n      }).case('Style', function (style) {\n        _this5._style = style;\n        _this5._styleId = style.id();\n        return _this5;\n      }).handle(arguments);\n    }\n    /**\n     * Gets the value of the cell.\n     * @returns {string|boolean|number|Date|RichText|undefined} The value of the cell.\n     */\n    /**\n    * Sets the value of the cell.\n    * @param {string|boolean|number|null|undefined|RichText} value - The value to set.\n    * @returns {Cell} The cell.\n    */\n    /**\n    * Sets the values in the range starting with the cell.\n    * @param {Array.<Array.<string|boolean|number|null|undefined>>} - 2D array of values to set.\n    * @returns {Range} The range that was set.\n    */\n  }, {\n    key: \"value\",\n    value: function value() {\n      var _this6 = this;\n      return new ArgHandler('Cell.value').case(function () {\n        if (_this6._value instanceof RichText) {\n          return _this6._value.getInstanceWithCellRef(_this6);\n        }\n        return _this6._value;\n      }).case(\"array\", function (values) {\n        var numRows = values.length;\n        var numCols = values[0].length;\n        var range = _this6.rangeTo(_this6.relativeCell(numRows - 1, numCols - 1));\n        return range.value(values);\n      }).case('*', function (value) {\n        _this6.clear();\n        if (value instanceof RichText) {\n          _this6._value = value.copy(_this6);\n        } else {\n          _this6._value = value;\n        }\n        return _this6;\n      }).handle(arguments);\n    }\n    /**\n     * Gets the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n  }, {\n    key: \"workbook\",\n    value: function workbook() {\n      return this.row().workbook();\n    }\n    /**\n     * Append horizontal page break after the cell.\n     * @returns {Cell} the cell.\n     */\n  }, {\n    key: \"addHorizontalPageBreak\",\n    value: function addHorizontalPageBreak() {\n      this.row().addPageBreak();\n      return this;\n    }\n    /* INTERNAL */\n    /**\n     * Gets the formula if a shared formula ref cell.\n     * @returns {string|undefined} The formula.\n     * @ignore\n     */\n  }, {\n    key: \"getSharedRefFormula\",\n    value: function getSharedRefFormula() {\n      return this._formulaType === \"shared\" ? this._formulaRef && this._formula : undefined;\n    }\n    /**\n     * Check if this cell uses a given shared a formula ID.\n     * @param {number} id - The shared formula ID.\n     * @returns {boolean} A flag indicating if shared.\n     * @ignore\n     */\n  }, {\n    key: \"sharesFormula\",\n    value: function sharesFormula(id) {\n      return this._formulaType === \"shared\" && this._sharedFormulaId === id;\n    }\n    /**\n     * Set a shared formula on the cell.\n     * @param {number} id - The shared formula index.\n     * @param {string} [formula] - The formula (if the reference cell).\n     * @param {string} [sharedRef] - The address of the shared range (if the reference cell).\n     * @returns {undefined}\n     * @ignore\n     */\n  }, {\n    key: \"setSharedFormula\",\n    value: function setSharedFormula(id, formula, sharedRef) {\n      this.clear();\n      this._formulaType = \"shared\";\n      this._sharedFormulaId = id;\n      this._formula = formula;\n      this._formulaRef = sharedRef;\n    }\n    /**\n     * Convert the cell to an XML object.\n     * @returns {{}} The XML form.\n     * @ignore\n     */\n  }, {\n    key: \"toXml\",\n    value: function toXml() {\n      // Create a node.\n      var node = {\n        name: 'c',\n        attributes: this._remainingAttributes || {},\n        // Start with any remaining attributes we don't current handle.\n        children: []\n      };\n\n      // Set the address.\n      node.attributes.r = this.address();\n      if (!_.isNil(this._formulaType)) {\n        // Add the formula.\n        var fNode = {\n          name: 'f',\n          attributes: this._remainingFormulaAttributes || {}\n        };\n        if (this._formulaType !== \"normal\") fNode.attributes.t = this._formulaType;\n        if (!_.isNil(this._formulaRef)) fNode.attributes.ref = this._formulaRef;\n        if (!_.isNil(this._sharedFormulaId)) fNode.attributes.si = this._sharedFormulaId;\n        if (!_.isNil(this._formula)) fNode.children = [this._formula];\n        node.children.push(fNode);\n      } else if (!_.isNil(this._value)) {\n        // Add the value. Don't emit value if a formula is set as Excel will show this stale value.\n        var type, text;\n        if (typeof this._value === \"string\") {\n          type = \"s\";\n          text = this.workbook().sharedStrings().getIndexForString(this._value);\n        } else if (typeof this._value === \"boolean\") {\n          type = \"b\";\n          text = this._value ? 1 : 0;\n        } else if (typeof this._value === \"number\") {\n          text = this._value;\n        } else if (this._value instanceof Date) {\n          text = dateConverter.dateToNumber(this._value);\n        } else if (this._value instanceof RichText || typeof this._value === \"object\" && this._value.constructor.name === \"RichText\") {\n          // Hack to make Jasmine test work\n          type = \"s\";\n          text = this.workbook().sharedStrings().getIndexForString(this._value.toXml());\n        }\n        if (type) node.attributes.t = type;\n        var vNode = {\n          name: 'v',\n          children: [text]\n        };\n        node.children.push(vNode);\n      }\n\n      // If the style is set, set the style ID.\n      if (!_.isNil(this._style)) {\n        node.attributes.s = this._style.id();\n      } else if (!_.isNil(this._styleId)) {\n        node.attributes.s = this._styleId;\n      }\n\n      // Add any remaining children that we don't currently handle.\n      if (this._remainingChildren) {\n        node.children = node.children.concat(this._remainingChildren);\n      }\n      return node;\n    }\n    /* PRIVATE */\n    /**\n     * Initialize the cell node.\n     * @param {{}|number} nodeOrColumnNumber - The existing node or the column number of a new cell.\n     * @param {number} [styleId] - The style ID for the new cell.\n     * @returns {undefined}\n     * @private\n     */\n  }, {\n    key: \"_init\",\n    value: function _init(nodeOrColumnNumber, styleId) {\n      if (_.isObject(nodeOrColumnNumber)) {\n        // Parse the existing node.\n        this._parseNode(nodeOrColumnNumber);\n      } else {\n        // This is a new cell.\n        this._columnNumber = nodeOrColumnNumber;\n        if (!_.isNil(styleId)) this._styleId = styleId;\n      }\n    }\n    /**\n     * Parse the existing node.\n     * @param {{}} node - The existing node.\n     * @returns {undefined}\n     * @private\n     */\n  }, {\n    key: \"_parseNode\",\n    value: function _parseNode(node) {\n      // Parse the column numbr out of the address.\n      var ref = addressConverter.fromAddress(node.attributes.r);\n      this._columnNumber = ref.columnNumber;\n\n      // Store the style ID if present.\n      if (!_.isNil(node.attributes.s)) this._styleId = node.attributes.s;\n\n      // Parse the formula if present..\n      var fNode = xmlq.findChild(node, 'f');\n      if (fNode) {\n        this._formulaType = fNode.attributes.t || \"normal\";\n        this._formulaRef = fNode.attributes.ref;\n        this._formula = fNode.children[0];\n        this._sharedFormulaId = fNode.attributes.si;\n        if (!_.isNil(this._sharedFormulaId)) {\n          // Update the sheet's max shared formula ID so we can set future IDs an index beyond this.\n          this.sheet().updateMaxSharedFormulaId(this._sharedFormulaId);\n        }\n\n        // Delete the known attributes.\n        delete fNode.attributes.t;\n        delete fNode.attributes.ref;\n        delete fNode.attributes.si;\n\n        // If any unknown attributes are still present, store them for later output.\n        if (!_.isEmpty(fNode.attributes)) this._remainingFormulaAttributes = fNode.attributes;\n      }\n\n      // Parse the value.\n      var type = node.attributes.t;\n      if (type === \"s\") {\n        // String value.\n        var vNode = xmlq.findChild(node, 'v');\n        if (vNode) {\n          var sharedIndex = vNode.children[0];\n          this._value = this.workbook().sharedStrings().getStringByIndex(sharedIndex);\n\n          // rich text\n          if (_.isArray(this._value)) {\n            this._value = new RichText(this._value);\n          }\n        } else {\n          this._value = '';\n        }\n      } else if (type === \"str\") {\n        // Simple string value.\n        var _vNode = xmlq.findChild(node, 'v');\n        this._value = _vNode && _vNode.children[0];\n      } else if (type === \"inlineStr\") {\n        // Inline string value: can be simple text or rich text.\n        var isNode = xmlq.findChild(node, 'is');\n        if (isNode.children[0].name === \"t\") {\n          var tNode = isNode.children[0];\n          this._value = tNode.children[0];\n        } else {\n          this._value = isNode.children;\n        }\n      } else if (type === \"b\") {\n        // Boolean value.\n        this._value = xmlq.findChild(node, 'v').children[0] === 1;\n      } else if (type === \"e\") {\n        // Error value.\n        var error = xmlq.findChild(node, 'v').children[0];\n        this._value = FormulaError.getError(error);\n      } else {\n        // Number value.\n        var _vNode2 = xmlq.findChild(node, 'v');\n        this._value = _vNode2 && Number(_vNode2.children[0]);\n      }\n\n      // Delete known attributes.\n      delete node.attributes.r;\n      delete node.attributes.s;\n      delete node.attributes.t;\n\n      // If any unknown attributes are still present, store them for later output.\n      if (!_.isEmpty(node.attributes)) this._remainingAttributes = node.attributes;\n\n      // Delete known children.\n      xmlq.removeChild(node, 'f');\n      xmlq.removeChild(node, 'v');\n      xmlq.removeChild(node, 'is');\n\n      // If any unknown children are still present, store them for later output.\n      if (!_.isEmpty(node.children)) this._remainingChildren = node.children;\n    }\n  }]);\n  return Cell;\n}();\nmodule.exports = Cell;\n\n/*\n<c r=\"A6\" s=\"1\" t=\"s\">\n    <v>2</v>\n</c>\n*/","map":null,"metadata":{},"sourceType":"script"}
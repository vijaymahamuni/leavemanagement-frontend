{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Project\\\\Front_end\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Project\\\\Front_end\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _ = require(\"lodash\");\nvar XML_DECLARATION = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?>\";\n\n/**\n * XML document builder.\n * @private\n */\nvar XmlBuilder = /*#__PURE__*/function () {\n  function XmlBuilder() {\n    _classCallCheck(this, XmlBuilder);\n  }\n  _createClass(XmlBuilder, [{\n    key: \"build\",\n    /**\n     * Build an XML string from the JSON object.\n     * @param {{}} node - The node.\n     * @returns {string} The XML text.\n     */\n    value: function build(node) {\n      this._i = 0;\n      var xml = this._build(node, '');\n      if (xml === '') return;\n      return XML_DECLARATION + xml;\n    }\n    /**\n     * Build the XML string. (This is the internal recursive method.)\n     * @param {{}} node - The node.\n     * @param {string} xml - The initial XML doc string.\n     * @returns {string} The generated XML element.\n     * @private\n     */\n  }, {\n    key: \"_build\",\n    value: function _build(node, xml) {\n      var _this = this;\n      // For CPU performance, JS engines don't truly concatenate strings; they create a tree of pointers to\n      // the various concatenated strings. The downside of this is that it consumes a lot of memory, which\n      // will cause problems with large workbooks. So periodically, we grab a character from the xml, which\n      // causes the JS engine to flatten the tree into a single string. Do this too often and CPU takes a hit.\n      // Too frequently and memory takes a hit. Every 100k nodes seems to be a good balance.\n      if (this._i++ % 1000000 === 0) {\n        this._c = xml[0];\n      }\n\n      // If the node has a toXml method, call it.\n      if (node && _.isFunction(node.toXml)) node = node.toXml();\n      if (_.isObject(node)) {\n        // If the node is an object, then it maps to an element. Check if it has a name.\n        if (!node.name) throw new Error(\"XML node does not have name: \".concat(JSON.stringify(node)));\n\n        // Add the opening tag.\n        xml += \"<\".concat(node.name);\n\n        // Add any node attributes\n        _.forOwn(node.attributes, function (value, name) {\n          xml += \" \".concat(name, \"=\\\"\").concat(_this._escapeString(value, true), \"\\\"\");\n        });\n        if (_.isEmpty(node.children)) {\n          // Self-close the tag if no children.\n          xml += \"/>\";\n        } else {\n          xml += \">\";\n\n          // Recursively add any children.\n          _.forEach(node.children, function (child) {\n            // Add the children to the XML.\n            xml = _this._build(child, xml);\n          });\n\n          // Close the tag.\n          xml += \"</\".concat(node.name, \">\");\n        }\n      } else if (!_.isNil(node)) {\n        // It not an object, this should be a text node. Just add it.\n        xml += this._escapeString(node);\n      }\n\n      // Return the updated XML element.\n      return xml;\n    }\n    /**\n     * Escape a string for use in XML by replacing &, \", ', <, and >.\n     * @param {*} value - The value to escape.\n     * @param {boolean} [isAttribute] - A flag indicating if this is an attribute.\n     * @returns {string} The escaped string.\n     * @private\n     */\n  }, {\n    key: \"_escapeString\",\n    value: function _escapeString(value, isAttribute) {\n      if (_.isNil(value)) return value;\n      value = value.toString().replace(/&/g, \"&amp;\") // Escape '&' first as the other escapes add them.\n      .replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n      if (isAttribute) {\n        value = value.replace(/\"/g, \"&quot;\");\n      }\n      return value;\n    }\n  }]);\n  return XmlBuilder;\n}();\nmodule.exports = XmlBuilder;","map":null,"metadata":{},"sourceType":"script"}
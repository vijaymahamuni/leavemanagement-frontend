{"ast":null,"code":"\"use strict\";\n\nvar _ = require(\"lodash\");\n\n/**\n * XML query methods.\n * @private\n */\nmodule.exports = {\n  /**\n   * Append a child to the node.\n   * @param {{}} node - The parent node.\n   * @param {{}} child - The child node.\n   * @returns {undefined}\n   */\n  appendChild: function appendChild(node, child) {\n    if (!node.children) node.children = [];\n    node.children.push(child);\n  },\n  /**\n   * Append a child if one with the given name is not found.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The child node name.\n   * @returns {{}} The child.\n   */\n  appendChildIfNotFound: function appendChildIfNotFound(node, name) {\n    var child = this.findChild(node, name);\n    if (!child) {\n      child = {\n        name: name,\n        attributes: {},\n        children: []\n      };\n      this.appendChild(node, child);\n    }\n    return child;\n  },\n  /**\n   * Find a child with the given name.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The name to find.\n   * @returns {undefined|{}} The child if found.\n   */\n  findChild: function findChild(node, name) {\n    return _.find(node.children, {\n      name: name\n    });\n  },\n  /**\n   * Get an attribute from a child node.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The name of the child node.\n   * @param {string} attribute - The name of the attribute.\n   * @returns {undefined|*} The value of the attribute if found.\n   */\n  getChildAttribute: function getChildAttribute(node, name, attribute) {\n    var child = this.findChild(node, name);\n    if (child) return child.attributes && child.attributes[attribute];\n  },\n  /**\n   * Returns a value indicating whether the node has a child with the given name.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The name of the child node.\n   * @returns {boolean} True if found, false otherwise.\n   */\n  hasChild: function hasChild(node, name) {\n    return _.some(node.children, {\n      name: name\n    });\n  },\n  /**\n   * Insert the child after the specified node.\n   * @param {{}} node - The parent node.\n   * @param {{}} child - The child node.\n   * @param {{}} after - The node to insert after.\n   * @returns {undefined}\n   */\n  insertAfter: function insertAfter(node, child, after) {\n    if (!node.children) node.children = [];\n    var index = node.children.indexOf(after);\n    node.children.splice(index + 1, 0, child);\n  },\n  /**\n   * Insert the child before the specified node.\n   * @param {{}} node - The parent node.\n   * @param {{}} child - The child node.\n   * @param {{}} before - The node to insert before.\n   * @returns {undefined}\n   */\n  insertBefore: function insertBefore(node, child, before) {\n    if (!node.children) node.children = [];\n    var index = node.children.indexOf(before);\n    node.children.splice(index, 0, child);\n  },\n  /**\n   * Insert a child node in the correct order.\n   * @param {{}} node - The parent node.\n   * @param {{}} child - The child node.\n   * @param {Array.<string>} nodeOrder - The order of the node names.\n   * @returns {undefined}\n   */\n  insertInOrder: function insertInOrder(node, child, nodeOrder) {\n    var childIndex = nodeOrder.indexOf(child.name);\n    if (node.children && childIndex >= 0) {\n      for (var i = childIndex + 1; i < nodeOrder.length; i++) {\n        var sibling = this.findChild(node, nodeOrder[i]);\n        if (sibling) {\n          this.insertBefore(node, child, sibling);\n          return;\n        }\n      }\n    }\n    this.appendChild(node, child);\n  },\n  /**\n   * Check if the node is empty (no attributes and no children).\n   * @param {{}} node - The node.\n   * @returns {boolean} True if empty, false otherwise.\n   */\n  isEmpty: function isEmpty(node) {\n    return _.isEmpty(node.children) && _.isEmpty(node.attributes);\n  },\n  /**\n   * Remove a child node.\n   * @param {{}} node - The parent node.\n   * @param {string|{}} child - The child node or name of node.\n   * @returns {undefined}\n   */\n  removeChild: function removeChild(node, child) {\n    if (!node.children) return;\n    if (typeof child === 'string') {\n      _.remove(node.children, {\n        name: child\n      });\n    } else {\n      var index = node.children.indexOf(child);\n      if (index >= 0) node.children.splice(index, 1);\n    }\n  },\n  /**\n   * Set/unset the attributes on the node.\n   * @param {{}} node - The node.\n   * @param {{}} attributes - The attributes to set.\n   * @returns {undefined}\n   */\n  setAttributes: function setAttributes(node, attributes) {\n    _.forOwn(attributes, function (value, attribute) {\n      if (_.isNil(value)) {\n        if (node.attributes) delete node.attributes[attribute];\n      } else {\n        if (!node.attributes) node.attributes = {};\n        node.attributes[attribute] = value;\n      }\n    });\n  },\n  /**\n   * Set attributes on a child node, creating the child if necessary.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The name of the child node.\n   * @param {{}} attributes - The attributes to set.\n   * @returns {{}} The child.\n   */\n  setChildAttributes: function setChildAttributes(node, name, attributes) {\n    var _this = this;\n    var child = this.findChild(node, name);\n    _.forOwn(attributes, function (value, attribute) {\n      if (_.isNil(value)) {\n        if (child && child.attributes) delete child.attributes[attribute];\n      } else {\n        if (!child) {\n          child = {\n            name: name,\n            attributes: {},\n            children: []\n          };\n          _this.appendChild(node, child);\n        }\n        if (!child.attributes) child.attributes = {};\n        child.attributes[attribute] = value;\n      }\n    });\n    return child;\n  },\n  /**\n   * Remove the child node if empty.\n   * @param {{}} node - The parent node.\n   * @param {string|{}} child - The child or name of child node.\n   * @returns {undefined}\n   */\n  removeChildIfEmpty: function removeChildIfEmpty(node, child) {\n    if (typeof child === 'string') child = this.findChild(node, child);\n    if (child && this.isEmpty(child)) this.removeChild(node, child);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}
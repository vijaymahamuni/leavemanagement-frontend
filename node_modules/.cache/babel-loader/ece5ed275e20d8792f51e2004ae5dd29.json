{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Project\\\\Front_end\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Project\\\\Front_end\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar sax = require(\"sax\");\nvar externals = require(\"./externals\");\n\n// Regex to check if string is all whitespace.\nvar allWhitespaceRegex = /^\\s+$/;\n\n/**\n * XML parser.\n * @private\n */\nvar XmlParser = /*#__PURE__*/function () {\n  function XmlParser() {\n    _classCallCheck(this, XmlParser);\n  }\n  _createClass(XmlParser, [{\n    key: \"parseAsync\",\n    /**\n     * Parse the XML text into a JSON object.\n     * @param {string} xmlText - The XML text.\n     * @returns {{}} The JSON object.\n     */\n    value: function parseAsync(xmlText) {\n      var _this = this;\n      return new externals.Promise(function (resolve, reject) {\n        // Create the SAX parser.\n        var parser = sax.parser(true);\n\n        // Parsed is the full parsed object. Current is the current node being parsed. Stack is the current stack of\n        // nodes leading to the current one.\n        var parsed, current;\n        var stack = [];\n\n        // On error: Reject the promise.\n        parser.onerror = reject;\n\n        // On text nodes: If it is all whitespace, do nothing. Otherwise, try to convert to a number and add as a child.\n        parser.ontext = function (text) {\n          if (allWhitespaceRegex.test(text)) {\n            if (current && current.attributes['xml:space'] === 'preserve') {\n              current.children.push(text);\n            }\n          } else {\n            current.children.push(_this._covertToNumberIfNumber(text));\n          }\n        };\n\n        // On open tag start: Create a child element. If this is the root element, set it as parsed. Otherwise, add\n        // it as a child to the current node.\n        parser.onopentagstart = function (node) {\n          var child = {\n            name: node.name,\n            attributes: {},\n            children: []\n          };\n          if (current) {\n            current.children.push(child);\n          } else {\n            parsed = child;\n          }\n          stack.push(child);\n          current = child;\n        };\n\n        // On close tag: Pop the stack.\n        parser.onclosetag = function (node) {\n          stack.pop();\n          current = stack[stack.length - 1];\n        };\n\n        // On attribute: Try to convert the value to a number and add to the current node.\n        parser.onattribute = function (attribute) {\n          current.attributes[attribute.name] = _this._covertToNumberIfNumber(attribute.value);\n        };\n\n        // On end: Resolve the promise.\n        parser.onend = function () {\n          return resolve(parsed);\n        };\n\n        // Start parsing the text.\n        parser.write(xmlText).close();\n      });\n    }\n    /**\n     * Convert the string to a number if it looks like one.\n     * @param {string} str - The string to convert.\n     * @returns {string|number} The number if converted or the string if not.\n     * @private\n     */\n  }, {\n    key: \"_covertToNumberIfNumber\",\n    value: function _covertToNumberIfNumber(str) {\n      var num = Number(str);\n      return num.toString() === str ? num : str;\n    }\n  }]);\n  return XmlParser;\n}();\nmodule.exports = XmlParser;","map":null,"metadata":{},"sourceType":"script"}
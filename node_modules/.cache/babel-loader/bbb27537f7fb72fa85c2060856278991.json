{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Project\\\\Front_end\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Project\\\\Front_end\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _ = require(\"lodash\");\nvar Cell = require(\"./Cell\");\nvar regexify = require(\"./regexify\");\nvar ArgHandler = require(\"./ArgHandler\");\nvar addressConverter = require('./addressConverter');\n\n/**\n * A row.\n */\nvar Row = /*#__PURE__*/function () {\n  // /**\n  //  * Creates a new instance of Row.\n  //  * @param {Sheet} sheet - The parent sheet.\n  //  * @param {{}} node - The row node.\n  //  */\n  function Row(sheet, node) {\n    _classCallCheck(this, Row);\n    this._sheet = sheet;\n    this._init(node);\n  }\n\n  /* PUBLIC */\n\n  /**\n   * Get the address of the row.\n   * @param {{}} [opts] - Options\n   * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n   * @param {boolean} [opts.anchored] - Anchor the address.\n   * @returns {string} The address\n   */\n  _createClass(Row, [{\n    key: \"address\",\n    value: function address(opts) {\n      return addressConverter.toAddress({\n        type: 'row',\n        rowNumber: this.rowNumber(),\n        sheetName: opts && opts.includeSheetName && this.sheet().name(),\n        rowAnchored: opts && opts.anchored\n      });\n    }\n    /**\n     * Get a cell in the row.\n     * @param {string|number} columnNameOrNumber - The name or number of the column.\n     * @returns {Cell} The cell.\n     */\n  }, {\n    key: \"cell\",\n    value: function cell(columnNameOrNumber) {\n      var columnNumber = columnNameOrNumber;\n      if (typeof columnNameOrNumber === 'string') {\n        columnNumber = addressConverter.columnNameToNumber(columnNameOrNumber);\n      }\n      if (columnNumber < 1) throw new RangeError(\"Invalid column number \".concat(columnNumber, \". Remember that spreadsheets use 1-based indexing.\"));\n\n      // Return an existing cell.\n      if (this._cells[columnNumber]) return this._cells[columnNumber];\n\n      // No cell exists for this.\n      // Check if there is an existing row/column style for the new cell.\n      var styleId;\n      var rowStyleId = this._node.attributes.s;\n      var columnStyleId = this.sheet().existingColumnStyleId(columnNumber);\n\n      // Row style takes priority. If a cell has both row and column styles it should have created a cell entry with a cell-specific style.\n      if (!_.isNil(rowStyleId)) styleId = rowStyleId;else if (!_.isNil(columnStyleId)) styleId = columnStyleId;\n\n      // Create the new cell.\n      var cell = new Cell(this, columnNumber, styleId);\n      this._cells[columnNumber] = cell;\n      return cell;\n    }\n    /**\n     * Gets the row height.\n     * @returns {undefined|number} The height (or undefined).\n     */\n    /**\n    * Sets the row height.\n    * @param {number} height - The height of the row.\n    * @returns {Row} The row.\n    */\n  }, {\n    key: \"height\",\n    value: function height() {\n      var _this = this;\n      return new ArgHandler('Row.height').case(function () {\n        return _this._node.attributes.customHeight ? _this._node.attributes.ht : undefined;\n      }).case('number', function (height) {\n        _this._node.attributes.ht = height;\n        _this._node.attributes.customHeight = 1;\n        return _this;\n      }).case('nil', function () {\n        delete _this._node.attributes.ht;\n        delete _this._node.attributes.customHeight;\n        return _this;\n      }).handle(arguments);\n    }\n    /**\n     * Gets a value indicating whether the row is hidden.\n     * @returns {boolean} A flag indicating whether the row is hidden.\n     */\n    /**\n    * Sets whether the row is hidden.\n    * @param {boolean} hidden - A flag indicating whether to hide the row.\n    * @returns {Row} The row.\n    */\n  }, {\n    key: \"hidden\",\n    value: function hidden() {\n      var _this2 = this;\n      return new ArgHandler(\"Row.hidden\").case(function () {\n        return _this2._node.attributes.hidden === 1;\n      }).case('boolean', function (hidden) {\n        if (hidden) _this2._node.attributes.hidden = 1;else delete _this2._node.attributes.hidden;\n        return _this2;\n      }).handle(arguments);\n    }\n    /**\n     * Gets the row number.\n     * @returns {number} The row number.\n     */\n  }, {\n    key: \"rowNumber\",\n    value: function rowNumber() {\n      return this._node.attributes.r;\n    }\n    /**\n     * Gets the parent sheet of the row.\n     * @returns {Sheet} The parent sheet.\n     */\n  }, {\n    key: \"sheet\",\n    value: function sheet() {\n      return this._sheet;\n    }\n    /**\n     * Gets an individual style.\n     * @param {string} name - The name of the style.\n     * @returns {*} The style.\n     */\n    /**\n    * Gets multiple styles.\n    * @param {Array.<string>} names - The names of the style.\n    * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.\n    */\n    /**\n    * Sets an individual style.\n    * @param {string} name - The name of the style.\n    * @param {*} value - The value to set.\n    * @returns {Cell} The cell.\n    */\n    /**\n    * Sets multiple styles.\n    * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.\n    * @returns {Cell} The cell.\n    */\n    /**\n    * Sets to a specific style\n    * @param {Style} style - Style object given from stylesheet.createStyle\n    * @returns {Cell} The cell.\n    */\n  }, {\n    key: \"style\",\n    value: function style() {\n      var _this3 = this;\n      return new ArgHandler(\"Row.style\").case('string', function (name) {\n        // Get single value\n        _this3._createStyleIfNeeded();\n        return _this3._style.style(name);\n      }).case('array', function (names) {\n        // Get list of values\n        var values = {};\n        names.forEach(function (name) {\n          values[name] = _this3.style(name);\n        });\n        return values;\n      }).case(['string', '*'], function (name, value) {\n        _this3._createCellStylesIfNeeded();\n\n        // Style each existing cell within this row. (Cells don't inherit ow/column styles.)\n        _.forEach(_this3._cells, function (cell) {\n          if (cell) cell.style(name, value);\n        });\n\n        // Set the style on the row.\n        _this3._createStyleIfNeeded();\n        _this3._style.style(name, value);\n        return _this3;\n      }).case('object', function (nameValues) {\n        // Object of key value pairs to set\n        for (var name in nameValues) {\n          if (!nameValues.hasOwnProperty(name)) continue;\n          var value = nameValues[name];\n          _this3.style(name, value);\n        }\n        return _this3;\n      }).case('Style', function (style) {\n        _this3._createCellStylesIfNeeded();\n\n        // Style each existing cell within this row. (Cells don't inherit ow/column styles.)\n        _.forEach(_this3._cells, function (cell) {\n          if (cell) cell.style(style);\n        });\n        _this3._style = style;\n        _this3._node.attributes.s = style.id();\n        _this3._node.attributes.customFormat = 1;\n        return _this3;\n      }).handle(arguments);\n    }\n    /**\n     * Get the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n  }, {\n    key: \"workbook\",\n    value: function workbook() {\n      return this.sheet().workbook();\n    }\n    /**\n     * Append horizontal page break after the row.\n     * @returns {Row} the row.\n     */\n  }, {\n    key: \"addPageBreak\",\n    value: function addPageBreak() {\n      this.sheet().horizontalPageBreaks().add(this.rowNumber());\n      return this;\n    }\n    /* INTERNAL */\n    /**\n     * Clear cells that are using a given shared formula ID.\n     * @param {number} sharedFormulaId - The shared formula ID.\n     * @returns {undefined}\n     * @ignore\n     */\n  }, {\n    key: \"clearCellsUsingSharedFormula\",\n    value: function clearCellsUsingSharedFormula(sharedFormulaId) {\n      this._cells.forEach(function (cell) {\n        if (!cell) return;\n        if (cell.sharesFormula(sharedFormulaId)) cell.clear();\n      });\n    }\n    /**\n     * Find a pattern in the row and optionally replace it.\n     * @param {string|RegExp} pattern - The search pattern.\n     * @param {string} [replacement] - The replacement text.\n     * @returns {Array.<Cell>} The matched cells.\n     * @ignore\n     */\n  }, {\n    key: \"find\",\n    value: function find(pattern, replacement) {\n      pattern = regexify(pattern);\n      var matches = [];\n      this._cells.forEach(function (cell) {\n        if (!cell) return;\n        if (cell.find(pattern, replacement)) matches.push(cell);\n      });\n      return matches;\n    }\n    /**\n     * Check if the row has a cell at the given column number.\n     * @param {number} columnNumber - The column number.\n     * @returns {boolean} True if a cell exists, false otherwise.\n     * @ignore\n     */\n  }, {\n    key: \"hasCell\",\n    value: function hasCell(columnNumber) {\n      if (columnNumber < 1) throw new RangeError(\"Invalid column number \".concat(columnNumber, \". Remember that spreadsheets use 1-based indexing.\"));\n      return !!this._cells[columnNumber];\n    }\n    /**\n     * Check if the column has a style defined.\n     * @returns {boolean} True if a style exists, false otherwise.\n     * @ignore\n     */\n  }, {\n    key: \"hasStyle\",\n    value: function hasStyle() {\n      return !_.isNil(this._node.attributes.s);\n    }\n    /**\n     * Returns the nax used column number.\n     * @returns {number} The max used column number.\n     * @ignore\n     */\n  }, {\n    key: \"minUsedColumnNumber\",\n    value: function minUsedColumnNumber() {\n      return _.findIndex(this._cells);\n    }\n    /**\n     * Returns the nax used column number.\n     * @returns {number} The max used column number.\n     * @ignore\n     */\n  }, {\n    key: \"maxUsedColumnNumber\",\n    value: function maxUsedColumnNumber() {\n      return this._cells.length - 1;\n    }\n    /**\n     * Convert the row to an object.\n     * @returns {{}} The object form.\n     * @ignore\n     */\n  }, {\n    key: \"toXml\",\n    value: function toXml() {\n      return this._node;\n    }\n    /* PRIVATE */\n    /**\n     * If a column node is already defined that intersects with this row and that column has a style set, we\n     * need to make sure that a cell node exists at the intersection so we can style it appropriately.\n     * Fetching the cell will force a new cell node to be created with a style matching the column.\n     * @returns {undefined}\n     * @private\n     */\n  }, {\n    key: \"_createCellStylesIfNeeded\",\n    value: function _createCellStylesIfNeeded() {\n      var _this4 = this;\n      this.sheet().forEachExistingColumnNumber(function (columnNumber) {\n        if (!_.isNil(_this4.sheet().existingColumnStyleId(columnNumber))) _this4.cell(columnNumber);\n      });\n    }\n    /**\n     * Create a style for this row if it doesn't already exist.\n     * @returns {undefined}\n     * @private\n     */\n  }, {\n    key: \"_createStyleIfNeeded\",\n    value: function _createStyleIfNeeded() {\n      if (!this._style) {\n        var styleId = this._node.attributes.s;\n        this._style = this.workbook().styleSheet().createStyle(styleId);\n        this._node.attributes.s = this._style.id();\n        this._node.attributes.customFormat = 1;\n      }\n    }\n    /**\n     * Initialize the row node.\n     * @param {{}} node - The row node.\n     * @returns {undefined}\n     * @private\n     */\n  }, {\n    key: \"_init\",\n    value: function _init(node) {\n      var _this5 = this;\n      this._node = node;\n      this._cells = [];\n      this._node.children.forEach(function (cellNode) {\n        var cell = new Cell(_this5, cellNode);\n        _this5._cells[cell.columnNumber()] = cell;\n      });\n      this._node.children = this._cells;\n    }\n  }]);\n  return Row;\n}();\nmodule.exports = Row;\n\n/*\n<row r=\"6\" spans=\"1:9\" x14ac:dyDescent=\"0.25\">\n    <c r=\"A6\" s=\"1\" t=\"s\">\n        <v>2</v>\n    </c>\n    <c r=\"B6\" s=\"1\"/>\n    <c r=\"C6\" s=\"1\"/>\n</row>\n*/","map":null,"metadata":{},"sourceType":"script"}
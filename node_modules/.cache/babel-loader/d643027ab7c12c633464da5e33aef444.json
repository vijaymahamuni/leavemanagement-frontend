{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Project\\\\Front_end\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Project\\\\Front_end\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _ = require(\"lodash\");\nvar fs = require(\"fs\");\nvar JSZip = require('jszip');\nvar externals = require(\"./externals\");\nvar regexify = require(\"./regexify\");\nvar blank = require(\"./blank\")();\nvar xmlq = require(\"./xmlq\");\nvar Sheet = require(\"./Sheet\");\nvar ContentTypes = require(\"./ContentTypes\");\nvar AppProperties = require(\"./AppProperties\");\nvar CoreProperties = require(\"./CoreProperties\");\nvar Relationships = require(\"./Relationships\");\nvar SharedStrings = require(\"./SharedStrings\");\nvar StyleSheet = require(\"./StyleSheet\");\nvar Encryptor = require(\"./Encryptor\");\nvar XmlParser = require(\"./XmlParser\");\nvar XmlBuilder = require(\"./XmlBuilder\");\nvar ArgHandler = require(\"./ArgHandler\");\nvar addressConverter = require(\"./addressConverter\");\n\n// Options for adding files to zip. Do not create folders and use a fixed time at epoch.\n// The default JSZip behavior uses current time, which causes idential workbooks to be different each time.\nvar zipFileOpts = {\n  date: new Date(0),\n  createFolders: false\n};\n\n// Initialize the parser and builder.\nvar xmlParser = new XmlParser();\nvar xmlBuilder = new XmlBuilder();\n\n// Initialize the encryptor if present (can be excluded in browser build).\nvar encryptor = typeof Encryptor === \"function\" && new Encryptor();\n\n// Characters not allowed in sheet names.\nvar badSheetNameChars = ['\\\\', '/', '*', '[', ']', ':', '?'];\n\n// Excel limits sheet names to 31 chars.\nvar maxSheetNameLength = 31;\n\n// Order of the nodes as defined by the spec.\nvar nodeOrder = [\"fileVersion\", \"fileSharing\", \"workbookPr\", \"workbookProtection\", \"bookViews\", \"sheets\", \"functionGroups\", \"externalReferences\", \"definedNames\", \"calcPr\", \"oleSize\", \"customWorkbookViews\", \"pivotCaches\", \"smartTagPr\", \"smartTagTypes\", \"webPublishing\", \"fileRecoveryPr\", \"webPublishObjects\", \"extLst\"];\n\n/**\n * A workbook.\n */\nvar Workbook = /*#__PURE__*/function () {\n  function Workbook() {\n    _classCallCheck(this, Workbook);\n  }\n  _createClass(Workbook, [{\n    key: \"activeSheet\",\n    /**\n     * Get the active sheet in the workbook.\n     * @returns {Sheet} The active sheet.\n     */\n    /**\n    * Set the active sheet in the workbook.\n    * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to activate. The sheet must not be hidden.\n    * @returns {Workbook} The workbook.\n    */\n    value: function activeSheet() {\n      var _this = this;\n      return new ArgHandler('Workbook.activeSheet').case(function () {\n        return _this._activeSheet;\n      }).case('*', function (sheet) {\n        // Get the sheet from name/index if needed.\n        if (!(sheet instanceof Sheet)) sheet = _this.sheet(sheet);\n\n        // Check if the sheet is hidden.\n        if (sheet.hidden()) throw new Error(\"You may not activate a hidden sheet.\");\n\n        // Deselect all sheets except the active one (mirroring ying Excel behavior).\n        _.forEach(_this._sheets, function (current) {\n          current.tabSelected(current === sheet);\n        });\n        _this._activeSheet = sheet;\n        return _this;\n      }).handle(arguments);\n    }\n    /**\n     * Add a new sheet to the workbook.\n     * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Sheet} The new sheet.\n     */\n  }, {\n    key: \"addSheet\",\n    value: function addSheet(name, indexOrBeforeSheet) {\n      return this._addSheet(name, indexOrBeforeSheet);\n    }\n    /**\n     * Gets a defined name scoped to the workbook.\n     * @param {string} name - The defined name.\n     * @returns {undefined|string|Cell|Range|Row|Column} What the defined name refers to or undefined if not found. Will return the string formula if not a Row, Column, Cell, or Range.\n     */\n    /**\n    * Set a defined name scoped to the workbook.\n    * @param {string} name - The defined name.\n    * @param {string|Cell|Range|Row|Column} refersTo - What the name refers to.\n    * @returns {Workbook} The workbook.\n    */\n  }, {\n    key: \"definedName\",\n    value: function definedName() {\n      var _this2 = this;\n      return new ArgHandler(\"Workbook.definedName\").case('string', function (name) {\n        return _this2.scopedDefinedName(undefined, name);\n      }).case(['string', '*'], function (name, refersTo) {\n        _this2.scopedDefinedName(undefined, name, refersTo);\n        return _this2;\n      }).handle(arguments);\n    }\n    /**\n     * Delete a sheet from the workbook.\n     * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.\n     * @returns {Workbook} The workbook.\n     */\n  }, {\n    key: \"deleteSheet\",\n    value: function deleteSheet(sheet) {\n      // Get the sheet to move.\n      if (!(sheet instanceof Sheet)) {\n        sheet = this.sheet(sheet);\n        if (!sheet) throw new Error(\"Invalid move sheet reference.\");\n      }\n\n      // Make sure we are not deleting the only visible sheet.\n      var visibleSheets = _.filter(this._sheets, function (sheet) {\n        return !sheet.hidden();\n      });\n      if (visibleSheets.length === 1 && visibleSheets[0] === sheet) {\n        throw new Error(\"This sheet may not be deleted as a workbook must contain at least one visible sheet.\");\n      }\n\n      // Remove the sheet.\n      var index = this._sheets.indexOf(sheet);\n      this._sheets.splice(index, 1);\n\n      // Set the new active sheet.\n      if (sheet === this.activeSheet()) {\n        if (index >= this._sheets.length) index--;\n        this.activeSheet(index);\n      }\n      return this;\n    }\n    /**\n     * Find the given pattern in the workbook and optionally replace it.\n     * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n     * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in each cell will be replaced.\n     * @returns {boolean} A flag indicating if the pattern was found.\n     */\n  }, {\n    key: \"find\",\n    value: function find(pattern, replacement) {\n      pattern = regexify(pattern);\n      var matches = [];\n      this._sheets.forEach(function (sheet) {\n        matches = matches.concat(sheet.find(pattern, replacement));\n      });\n      return matches;\n    }\n    /**\n     * Move a sheet to a new position.\n     * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Workbook} The workbook.\n     */\n  }, {\n    key: \"moveSheet\",\n    value: function moveSheet(sheet, indexOrBeforeSheet) {\n      // Get the sheet to move.\n      if (!(sheet instanceof Sheet)) {\n        sheet = this.sheet(sheet);\n        if (!sheet) throw new Error(\"Invalid move sheet reference.\");\n      }\n\n      // Get the to/from indexes.\n      var from = this._sheets.indexOf(sheet);\n      var to;\n      if (_.isNil(indexOrBeforeSheet)) {\n        to = this._sheets.length - 1;\n      } else if (_.isInteger(indexOrBeforeSheet)) {\n        to = indexOrBeforeSheet;\n      } else {\n        if (!(indexOrBeforeSheet instanceof Sheet)) {\n          indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);\n          if (!indexOrBeforeSheet) throw new Error(\"Invalid before sheet reference.\");\n        }\n        to = this._sheets.indexOf(indexOrBeforeSheet);\n      }\n\n      // Insert the sheet at the appropriate place.\n      this._sheets.splice(to, 0, this._sheets.splice(from, 1)[0]);\n      return this;\n    }\n    /**\n     * Generates the workbook output.\n     * @param {string} [type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.\n     * @returns {Promise<string|Uint8Array|ArrayBuffer|Blob|Buffer>} The data.\n     */\n    /**\n    * Generates the workbook output.\n    * @param {{}} [opts] Options\n    * @param {string} [opts.type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.\n    * @param {string} [opts.password] - The password to use to encrypt the workbook.\n    * @returns {Promise<string|Uint8Array|ArrayBuffer|Blob|Buffer>} The data.\n    */\n  }, {\n    key: \"outputAsync\",\n    value: function outputAsync(opts) {\n      var _this3 = this;\n      opts = opts || {};\n      if (typeof opts === 'string') opts = {\n        type: opts\n      };\n      this._setSheetRefs();\n      var definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n      this._sheets.forEach(function (sheet, i) {\n        if (!sheet._autoFilter) return;\n        if (!definedNamesNode) {\n          definedNamesNode = {\n            name: \"definedNames\",\n            attributes: {},\n            children: []\n          };\n          xmlq.insertInOrder(_this3._node, definedNamesNode, nodeOrder);\n        }\n        xmlq.appendChild(definedNamesNode, {\n          name: \"definedName\",\n          attributes: {\n            name: \"_xlnm._FilterDatabase\",\n            localSheetId: i,\n            hidden: \"1\"\n          },\n          children: [sheet._autoFilter.address({\n            includeSheetName: true,\n            anchored: true\n          })]\n        });\n      });\n      this._sheetsNode.children = [];\n      this._sheets.forEach(function (sheet, i) {\n        var sheetPath = \"xl/worksheets/sheet\".concat(i + 1, \".xml\");\n        var sheetRelsPath = \"xl/worksheets/_rels/sheet\".concat(i + 1, \".xml.rels\");\n        var sheetXmls = sheet.toXmls();\n        var relationship = _this3._relationships.findById(sheetXmls.id.attributes['r:id']);\n        relationship.attributes.Target = \"worksheets/sheet\".concat(i + 1, \".xml\");\n        _this3._sheetsNode.children.push(sheetXmls.id);\n        _this3._zip.file(sheetPath, xmlBuilder.build(sheetXmls.sheet), zipFileOpts);\n        var relationshipsXml = xmlBuilder.build(sheetXmls.relationships);\n        if (relationshipsXml) {\n          _this3._zip.file(sheetRelsPath, relationshipsXml, zipFileOpts);\n        } else {\n          _this3._zip.remove(sheetRelsPath);\n        }\n      });\n\n      // Set the app security to true if a password is set, false if not.\n      // this._appProperties.isSecure(!!opts.password);\n\n      // Convert the various components to XML strings and add them to the zip.\n      this._zip.file(\"[Content_Types].xml\", xmlBuilder.build(this._contentTypes), zipFileOpts);\n      this._zip.file(\"docProps/app.xml\", xmlBuilder.build(this._appProperties), zipFileOpts);\n      this._zip.file(\"docProps/core.xml\", xmlBuilder.build(this._coreProperties), zipFileOpts);\n      this._zip.file(\"xl/_rels/workbook.xml.rels\", xmlBuilder.build(this._relationships), zipFileOpts);\n      this._zip.file(\"xl/sharedStrings.xml\", xmlBuilder.build(this._sharedStrings), zipFileOpts);\n      this._zip.file(\"xl/styles.xml\", xmlBuilder.build(this._styleSheet), zipFileOpts);\n      this._zip.file(\"xl/workbook.xml\", xmlBuilder.build(this._node), zipFileOpts);\n\n      // Generate the zip.\n      return this._zip.generateAsync({\n        type: \"nodebuffer\",\n        compression: \"DEFLATE\"\n      }).then(function (output) {\n        // If a password is set, encrypt the workbook.\n        if (opts.password) output = encryptor.encrypt(output, opts.password);\n\n        // Convert and return\n        return _this3._convertBufferToOutput(output, opts.type);\n      });\n    }\n    /**\n     * Gets the sheet with the provided name or index (0-based).\n     * @param {string|number} sheetNameOrIndex - The sheet name or index.\n     * @returns {Sheet|undefined} The sheet or undefined if not found.\n     */\n  }, {\n    key: \"sheet\",\n    value: function sheet(sheetNameOrIndex) {\n      if (_.isInteger(sheetNameOrIndex)) return this._sheets[sheetNameOrIndex];\n      return _.find(this._sheets, function (sheet) {\n        return sheet.name() === sheetNameOrIndex;\n      });\n    }\n    /**\n     * Get an array of all the sheets in the workbook.\n     * @returns {Array.<Sheet>} The sheets.\n     */\n  }, {\n    key: \"sheets\",\n    value: function sheets() {\n      return this._sheets.slice();\n    }\n    /**\n     * Gets an individual property.\n     * @param {string} name - The name of the property.\n     * @returns {*} The property.\n     */\n    /**\n    * Gets multiple properties.\n    * @param {Array.<string>} names - The names of the properties.\n    * @returns {object.<string, *>} Object whose keys are the property names and values are the properties.\n    */\n    /**\n    * Sets an individual property.\n    * @param {string} name - The name of the property.\n    * @param {*} value - The value to set.\n    * @returns {Workbook} The workbook.\n    */\n    /**\n    * Sets multiple properties.\n    * @param {object.<string, *>} properties - Object whose keys are the property names and values are the values to set.\n    * @returns {Workbook} The workbook.\n    */\n  }, {\n    key: \"property\",\n    value: function property() {\n      var _this4 = this;\n      return new ArgHandler(\"Workbook.property\").case('string', function (name) {\n        // Get single value\n        return _this4._coreProperties.get(name);\n      }).case('array', function (names) {\n        // Get list of values\n        var values = {};\n        names.forEach(function (name) {\n          values[name] = _this4._coreProperties.get(name);\n        });\n        return values;\n      }).case(['string', '*'], function (name, value) {\n        // Set a single value for all cells to a single value\n        _this4._coreProperties.set(name, value);\n        return _this4;\n      }).case('object', function (nameValues) {\n        // Object of key value pairs to set\n        for (var name in nameValues) {\n          if (!nameValues.hasOwnProperty(name)) continue;\n          var value = nameValues[name];\n          _this4._coreProperties.set(name, value);\n        }\n        return _this4;\n      }).handle(arguments);\n    }\n    /**\n     * Get access to core properties object\n     * @returns {CoreProperties} The core properties.\n     */\n  }, {\n    key: \"properties\",\n    value: function properties() {\n      return this._coreProperties;\n    }\n    /**\n     * Write the workbook to file. (Not supported in browsers.)\n     * @param {string} path - The path of the file to write.\n     * @param {{}} [opts] - Options\n     * @param {string} [opts.password] - The password to encrypt the workbook.\n     * @returns {Promise.<undefined>} A promise.\n     */\n  }, {\n    key: \"toFileAsync\",\n    value: function toFileAsync(path, opts) {\n      if (process.browser) throw new Error(\"Workbook.toFileAsync is not supported in the browser.\");\n      return this.outputAsync(opts).then(function (data) {\n        return new externals.Promise(function (resolve, reject) {\n          fs.writeFile(path, data, function (err) {\n            if (err) return reject(err);\n            resolve();\n          });\n        });\n      });\n    }\n    /**\n     * Gets a scoped defined name.\n     * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.\n     * @param {string} name - The defined name.\n     * @returns {undefined|Cell|Range|Row|Column} What the defined name refers to.\n     * @ignore\n     */\n    /**\n    * Sets a scoped defined name.\n    * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.\n    * @param {string} name - The defined name.\n    * @param {undefined|Cell|Range|Row|Column} refersTo - What the defined name refers to.\n    * @returns {Workbook} The workbook.\n    * @ignore\n    */\n  }, {\n    key: \"scopedDefinedName\",\n    value: function scopedDefinedName(sheetScope, name, refersTo) {\n      var _this5 = this;\n      var definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n      var definedNameNode = definedNamesNode && _.find(definedNamesNode.children, function (node) {\n        return node.attributes.name === name && node.localSheet === sheetScope;\n      });\n      return new ArgHandler('Workbook.scopedDefinedName').case(['*', 'string'], function () {\n        // Get the address from the definedNames node.\n        var refersTo = definedNameNode && definedNameNode.children[0];\n        if (!refersTo) return undefined;\n\n        // Try to parse the address.\n        var ref = addressConverter.fromAddress(refersTo);\n        if (!ref) return refersTo;\n\n        // Load the appropriate selection type.\n        var sheet = _this5.sheet(ref.sheetName);\n        if (ref.type === 'cell') return sheet.cell(ref.rowNumber, ref.columnNumber);\n        if (ref.type === 'range') return sheet.range(ref.startRowNumber, ref.startColumnNumber, ref.endRowNumber, ref.endColumnNumber);\n        if (ref.type === 'row') return sheet.row(ref.rowNumber);\n        if (ref.type === 'column') return sheet.column(ref.columnNumber);\n        return refersTo;\n      }).case(['*', 'string', 'nil'], function () {\n        if (definedNameNode) xmlq.removeChild(definedNamesNode, definedNameNode);\n        if (definedNamesNode && !definedNamesNode.children.length) xmlq.removeChild(_this5._node, definedNamesNode);\n        return _this5;\n      }).case(['*', 'string', '*'], function () {\n        if (typeof refersTo !== 'string') {\n          refersTo = refersTo.address({\n            includeSheetName: true,\n            anchored: true\n          });\n        }\n        if (!definedNamesNode) {\n          definedNamesNode = {\n            name: \"definedNames\",\n            attributes: {},\n            children: []\n          };\n          xmlq.insertInOrder(_this5._node, definedNamesNode, nodeOrder);\n        }\n        if (!definedNameNode) {\n          definedNameNode = {\n            name: \"definedName\",\n            attributes: {\n              name: name\n            },\n            children: [refersTo]\n          };\n          if (sheetScope) definedNameNode.localSheet = sheetScope;\n          xmlq.appendChild(definedNamesNode, definedNameNode);\n        }\n        definedNameNode.children = [refersTo];\n        return _this5;\n      }).handle(arguments);\n    }\n    /**\n     * Get the shared strings table.\n     * @returns {SharedStrings} The shared strings table.\n     * @ignore\n     */\n  }, {\n    key: \"sharedStrings\",\n    value: function sharedStrings() {\n      return this._sharedStrings;\n    }\n    /**\n     * Get the style sheet.\n     * @returns {StyleSheet} The style sheet.\n     * @ignore\n     */\n  }, {\n    key: \"styleSheet\",\n    value: function styleSheet() {\n      return this._styleSheet;\n    }\n    /**\n     * Add a new sheet to the workbook.\n     * \n     * **WARN:** this function has limits:  if you clone a sheet with some images or other things link outside the Sheet object, these things in the cloned sheet will be locked when you open in MS Excel app.\n     * @param {Sheet} from - The sheet to be cloned.\n     * @param {string} name - The name of the new sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Sheet} The new sheet.\n     */\n  }, {\n    key: \"cloneSheet\",\n    value: function cloneSheet(from, name, indexOrBeforeSheet) {\n      if (!from || !(from instanceof Sheet)) throw new Error(\"Invalid clone from.\");\n      return this._addSheet(name, indexOrBeforeSheet, function () {\n        var cloneXml = function cloneXml(node) {\n          // If the node has a toXml method, call it.\n          if (node && _.isFunction(node.toXml)) node = node.toXml();\n          if (typeof node === 'object') {\n            if (node.name) {\n              var result = {\n                name: node.name,\n                attributes: {},\n                children: []\n              };\n              _.forOwn(node.attributes, function (value, name) {\n                result.attributes[name] = value;\n              });\n              var chld;\n              if (node.children) {\n                node.children.forEach(function (child) {\n                  chld = cloneXml(child);\n                  if (child !== null) {\n                    result.children.push(chld);\n                  }\n                });\n              }\n              return result;\n            }\n          } else if (node !== null) {\n            return node;\n          }\n          return null;\n        };\n\n        // clone SheetNode & relationshipNode from source\n        var fromXml = from.toXmls();\n        var sheetNode = cloneXml(fromXml.sheet);\n        var relationshipNode = cloneXml(fromXml.relationships);\n        return {\n          sheetNode: sheetNode,\n          relationshipNode: relationshipNode\n        };\n      });\n    }\n    /**\n     * Add a new sheet to the workbook.\n     * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @param {callback} [getTemplateNodes] optional callback function for template nodes\n     * @returns {Sheet} The new sheet.\n     * @private\n     */\n  }, {\n    key: \"_addSheet\",\n    value: function _addSheet(name, indexOrBeforeSheet, getTemplateNodes) {\n      // Validate the sheet name.\n      if (!name || typeof name !== \"string\") throw new Error(\"Invalid sheet name.\");\n      if (_.some(badSheetNameChars, function (char) {\n        return name.indexOf(char) >= 0;\n      })) throw new Error(\"Sheet name may not contain any of the following characters: \".concat(badSheetNameChars.join(\" \")));\n      if (name.length > maxSheetNameLength) throw new Error(\"Sheet name may not be greater than \".concat(maxSheetNameLength, \" characters.\"));\n      if (this.sheet(name)) throw new Error(\"Sheet with name \\\"\".concat(name, \"\\\" already exists.\"));\n\n      // Get the destination index of new sheet.\n      var index;\n      if (_.isNil(indexOrBeforeSheet)) {\n        index = this._sheets.length;\n      } else if (_.isInteger(indexOrBeforeSheet)) {\n        index = indexOrBeforeSheet;\n      } else {\n        if (!(indexOrBeforeSheet instanceof Sheet)) {\n          indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);\n          if (!indexOrBeforeSheet) throw new Error(\"Invalid before sheet reference.\");\n        }\n        index = this._sheets.indexOf(indexOrBeforeSheet);\n      }\n\n      // Add a new relationship for the new sheet and create the new sheet ID node.\n      var relationship = this._relationships.add(\"worksheet\"); // Leave target blank as it will be filled later.\n      var sheetIdNode = {\n        name: \"sheet\",\n        attributes: {\n          name: name,\n          sheetId: ++this._maxSheetId,\n          'r:id': relationship.attributes.Id\n        },\n        children: []\n      };\n\n      // Create the new sheet.\n      var sheet;\n      if (getTemplateNodes) {\n        var _getTemplateNodes = getTemplateNodes(),\n          sheetNode = _getTemplateNodes.sheetNode,\n          relationshipNode = _getTemplateNodes.relationshipNode;\n        sheet = new Sheet(this, sheetIdNode, sheetNode, relationshipNode);\n      } else {\n        sheet = new Sheet(this, sheetIdNode);\n      }\n\n      // Insert the sheet at the appropriate index.\n      this._sheets.splice(index, 0, sheet);\n      return sheet;\n    }\n    /**\n     * Initialize the workbook. (This is separated from the constructor to ease testing.)\n     * @param {string|ArrayBuffer|Uint8Array|Buffer|Blob} data - The data to load.\n     * @param {{}} [opts] - Options\n     * @param {boolean} [opts.base64=false] - No used unless input is a string. True if the input string is base64 encoded, false for binary.\n     * @returns {Promise.<Workbook>} The workbook.\n     * @private\n     */\n  }, {\n    key: \"_initAsync\",\n    value: function _initAsync(data, opts) {\n      var _this6 = this;\n      opts = opts || {};\n      this._maxSheetId = 0;\n      this._sheets = [];\n      return externals.Promise.resolve().then(function () {\n        // Make sure the input is a Buffer\n        return _this6._convertInputToBufferAsync(data, opts.base64).then(function (buffer) {\n          data = buffer;\n        });\n      }).then(function () {\n        if (!opts.password) return;\n        return encryptor.decryptAsync(data, opts.password).then(function (decrypted) {\n          data = decrypted;\n        });\n      }).then(function () {\n        return JSZip.loadAsync(data);\n      }).then(function (zip) {\n        _this6._zip = zip;\n        return _this6._parseNodesAsync([\"[Content_Types].xml\", \"docProps/app.xml\", \"docProps/core.xml\", \"xl/_rels/workbook.xml.rels\", \"xl/sharedStrings.xml\", \"xl/styles.xml\", \"xl/workbook.xml\"]);\n      }).then(function (nodes) {\n        var contentTypesNode = nodes[0];\n        var appPropertiesNode = nodes[1];\n        var corePropertiesNode = nodes[2];\n        var relationshipsNode = nodes[3];\n        var sharedStringsNode = nodes[4];\n        var styleSheetNode = nodes[5];\n        var workbookNode = nodes[6];\n\n        // Load the various components.\n        _this6._contentTypes = new ContentTypes(contentTypesNode);\n        _this6._appProperties = new AppProperties(appPropertiesNode);\n        _this6._coreProperties = new CoreProperties(corePropertiesNode);\n        _this6._relationships = new Relationships(relationshipsNode);\n        _this6._sharedStrings = new SharedStrings(sharedStringsNode);\n        _this6._styleSheet = new StyleSheet(styleSheetNode);\n        _this6._node = workbookNode;\n\n        // Add the shared strings relationship if it doesn't exist.\n        if (!_this6._relationships.findByType(\"sharedStrings\")) {\n          _this6._relationships.add(\"sharedStrings\", \"sharedStrings.xml\");\n        }\n\n        // Add the shared string content type if it doesn't exist.\n        if (!_this6._contentTypes.findByPartName(\"/xl/sharedStrings.xml\")) {\n          _this6._contentTypes.add(\"/xl/sharedStrings.xml\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\");\n        }\n\n        // Kill the calc chain. It's not required and the workbook will corrupt unless we keep it up to date.\n        _this6._zip.remove(\"xl/calcChain.xml\");\n\n        // Load each sheet.\n        _this6._sheetsNode = xmlq.findChild(_this6._node, \"sheets\");\n        return externals.Promise.all(_.map(_this6._sheetsNode.children, function (sheetIdNode, i) {\n          if (sheetIdNode.attributes.sheetId > _this6._maxSheetId) _this6._maxSheetId = sheetIdNode.attributes.sheetId;\n          return _this6._parseNodesAsync([\"xl/worksheets/sheet\".concat(i + 1, \".xml\"), \"xl/worksheets/_rels/sheet\".concat(i + 1, \".xml.rels\")]).then(function (nodes) {\n            var sheetNode = nodes[0];\n            var sheetRelationshipsNode = nodes[1];\n\n            // Insert at position i as the promises will resolve at different times.\n            _this6._sheets[i] = new Sheet(_this6, sheetIdNode, sheetNode, sheetRelationshipsNode);\n          });\n        }));\n      }).then(function () {\n        return _this6._parseSheetRefs();\n      }).then(function () {\n        return _this6;\n      });\n    }\n    /**\n     * Parse files out of zip into XML node objects.\n     * @param {Array.<string>} names - The file names to parse.\n     * @returns {Promise.<Array.<{}>>} An array of the parsed objects.\n     * @private\n     */\n  }, {\n    key: \"_parseNodesAsync\",\n    value: function _parseNodesAsync(names) {\n      var _this7 = this;\n      return externals.Promise.all(_.map(names, function (name) {\n        return _this7._zip.file(name);\n      })).then(function (files) {\n        return externals.Promise.all(_.map(files, function (file) {\n          return file && file.async(\"string\");\n        }));\n      }).then(function (texts) {\n        return externals.Promise.all(_.map(texts, function (text) {\n          return text && xmlParser.parseAsync(text);\n        }));\n      });\n    }\n    /**\n     * Parse the sheet references out so we can reorder freely.\n     * @returns {undefined}\n     * @private\n     */\n  }, {\n    key: \"_parseSheetRefs\",\n    value: function _parseSheetRefs() {\n      var _this8 = this;\n      // Parse the active sheet.\n      var bookViewsNode = xmlq.findChild(this._node, \"bookViews\");\n      var workbookViewNode = bookViewsNode && xmlq.findChild(bookViewsNode, \"workbookView\");\n      var activeTabId = workbookViewNode && workbookViewNode.attributes.activeTab || 0;\n      this._activeSheet = this._sheets[activeTabId];\n\n      // Set the location sheet on the defined name nodes. The defined name should point to the index of the sheet\n      // but reordering sheets messes this up. So store it on the node and we'll update the index on XML build.\n      var definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n      if (definedNamesNode) {\n        _.forEach(definedNamesNode.children, function (definedNameNode) {\n          if (definedNameNode.attributes.hasOwnProperty(\"localSheetId\")) {\n            definedNameNode.localSheet = _this8._sheets[definedNameNode.attributes.localSheetId];\n          }\n        });\n      }\n    }\n    /**\n     * Set the proper sheet references in the XML.\n     * @returns {undefined}\n     * @private\n     */\n  }, {\n    key: \"_setSheetRefs\",\n    value: function _setSheetRefs() {\n      var _this9 = this;\n      // Set the active sheet.\n      var bookViewsNode = xmlq.findChild(this._node, \"bookViews\");\n      if (!bookViewsNode) {\n        bookViewsNode = {\n          name: 'bookViews',\n          attributes: {},\n          children: []\n        };\n        xmlq.insertInOrder(this._node, bookViewsNode, nodeOrder);\n      }\n      var workbookViewNode = xmlq.findChild(bookViewsNode, \"workbookView\");\n      if (!workbookViewNode) {\n        workbookViewNode = {\n          name: 'workbookView',\n          attributes: {},\n          children: []\n        };\n        xmlq.appendChild(bookViewsNode, workbookViewNode);\n      }\n      workbookViewNode.attributes.activeTab = this._sheets.indexOf(this._activeSheet);\n\n      // Set the defined names local sheet indexes.\n      var definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n      if (definedNamesNode) {\n        _.forEach(definedNamesNode.children, function (definedNameNode) {\n          if (definedNameNode.localSheet) {\n            definedNameNode.attributes.localSheetId = _this9._sheets.indexOf(definedNameNode.localSheet);\n          }\n        });\n      }\n    }\n    /**\n     * Convert buffer to desired output format\n     * @param {Buffer} buffer - The buffer\n     * @param {string} type - The type to convert to: buffer/nodebuffer, blob, base64, binarystring, uint8array, arraybuffer\n     * @returns {Buffer|Blob|string|Uint8Array|ArrayBuffer} The output\n     * @private\n     */\n  }, {\n    key: \"_convertBufferToOutput\",\n    value: function _convertBufferToOutput(buffer, type) {\n      if (!type) type = process.browser ? \"blob\" : \"nodebuffer\";\n      if (type === \"buffer\" || type === \"nodebuffer\") return buffer;\n      if (process.browser && type === \"blob\") return new Blob([buffer], {\n        type: Workbook.MIME_TYPE\n      });\n      if (type === \"base64\") return buffer.toString(\"base64\");\n      if (type === \"binarystring\") return buffer.toString(\"utf8\");\n      if (type === \"uint8array\") return new Uint8Array(buffer);\n      if (type === \"arraybuffer\") return new Uint8Array(buffer).buffer;\n      throw new Error(\"Output type '\".concat(type, \"' not supported.\"));\n    }\n    /**\n     * Convert input to buffer\n     * @param {Buffer|Blob|string|Uint8Array|ArrayBuffer} input - The input\n     * @param {boolean} [base64=false] - Only applies if input is a string. If true, the string is base64 encoded, false for binary\n     * @returns {Promise.<Buffer>} The buffer.\n     * @private\n     */\n  }, {\n    key: \"_convertInputToBufferAsync\",\n    value: function _convertInputToBufferAsync(input, base64) {\n      return externals.Promise.resolve().then(function () {\n        if (Buffer.isBuffer(input)) return input;\n        if (process.browser && input instanceof Blob) {\n          return new externals.Promise(function (resolve) {\n            var fileReader = new FileReader();\n            fileReader.onload = function (event) {\n              resolve(Buffer.from(event.target.result));\n            };\n            fileReader.readAsArrayBuffer(input);\n          });\n        }\n        if (typeof input === \"string\" && base64) return Buffer.from(input, \"base64\");\n        if (typeof input === \"string\" && !base64) return Buffer.from(input, \"utf8\");\n        if (input instanceof Uint8Array || input instanceof ArrayBuffer) return Buffer.from(input);\n        throw new Error(\"Input type unknown.\");\n      });\n    }\n  }], [{\n    key: \"fromBlankAsync\",\n    /**\n     * Create a new blank workbook.\n     * @returns {Promise.<Workbook>} The workbook.\n     * @ignore\n     */\n    value: function fromBlankAsync() {\n      return Workbook.fromDataAsync(blank);\n    }\n    /**\n     * Loads a workbook from a data object. (Supports any supported [JSZip data types]{@link https://stuk.github.io/jszip/documentation/api_jszip/load_async.html}.)\n     * @param {string|Array.<number>|ArrayBuffer|Uint8Array|Buffer|Blob|Promise.<*>} data - The data to load.\n     * @param {{}} [opts] - Options\n     * @returns {Promise.<Workbook>} The workbook.\n     * @ignore\n     */\n  }, {\n    key: \"fromDataAsync\",\n    value: function fromDataAsync(data, opts) {\n      return new Workbook()._initAsync(data, opts);\n    }\n    /**\n     * Loads a workbook from file.\n     * @param {string} path - The path to the workbook.\n     * @param {{}} [opts] - Options\n     * @returns {Promise.<Workbook>} The workbook.\n     * @ignore\n     */\n  }, {\n    key: \"fromFileAsync\",\n    value: function fromFileAsync(path, opts) {\n      if (process.browser) throw new Error(\"Workbook.fromFileAsync is not supported in the browser\");\n      return new externals.Promise(function (resolve, reject) {\n        fs.readFile(path, function (err, data) {\n          if (err) return reject(err);\n          resolve(data);\n        });\n      }).then(function (data) {\n        return Workbook.fromDataAsync(data, opts);\n      });\n    }\n  }]);\n  return Workbook;\n}();\n/**\n * The XLSX mime type.\n * @type {string}\n * @ignore\n */\nWorkbook.MIME_TYPE = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\nmodule.exports = Workbook;\n\n/*\nxl/workbook.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<workbook xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x15\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\">\n\t<fileVersion appName=\"xl\" lastEdited=\"7\" lowestEdited=\"7\" rupBuild=\"16925\"/>\n\t<workbookPr defaultThemeVersion=\"164011\"/>\n\t<mc:AlternateContent xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\">\n\t\t<mc:Choice Requires=\"x15\">\n\t\t\t<x15ac:absPath url=\"\\path\\to\\file\" xmlns:x15ac=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/ac\"/>\n\t\t</mc:Choice>\n\t</mc:AlternateContent>\n\t<bookViews>\n\t\t<workbookView xWindow=\"3720\" yWindow=\"0\" windowWidth=\"27870\" windowHeight=\"12795\"/>\n\t</bookViews>\n\t<sheets>\n\t\t<sheet name=\"Sheet1\" sheetId=\"1\" r:id=\"rId1\"/>\n\t</sheets>\n\t<calcPr calcId=\"171027\"/>\n\t<extLst>\n\t\t<ext uri=\"{140A7094-0E35-4892-8432-C4D2E57EDEB5}\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\">\n\t\t\t<x15:workbookPr chartTrackingRefBase=\"1\"/>\n\t\t</ext>\n\t</extLst>\n</workbook>\n// */","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Project\\\\Front_end\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Project\\\\Front_end\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _ = require(\"lodash\");\n\n/**\n * Method argument handler. Used for overloading methods.\n * @private\n */\nvar ArgHandler = /*#__PURE__*/function () {\n  /**\n   * Creates a new instance of ArgHandler.\n   * @param {string} name - The method name to use in error messages.\n   */\n  function ArgHandler(name) {\n    _classCallCheck(this, ArgHandler);\n    this._name = name;\n    this._cases = [];\n  }\n\n  /**\n   * Add a case.\n   * @param {string|Array.<string>} [types] - The type or types of arguments to match this case.\n   * @param {Function} handler - The function to call when this case is matched.\n   * @returns {ArgHandler} The handler for chaining.\n   */\n  _createClass(ArgHandler, [{\n    key: \"case\",\n    value: function _case(types, handler) {\n      if (arguments.length === 1) {\n        handler = types;\n        types = [];\n      }\n      if (!Array.isArray(types)) types = [types];\n      this._cases.push({\n        types: types,\n        handler: handler\n      });\n      return this;\n    }\n    /**\n     * Handle the method arguments by checking each case in order until one matches and then call its handler.\n     * @param {Arguments|Array.<*>} args - The method arguments.\n     * @returns {*} The result of the handler.\n     * @throws {Error} Throws if no case matches.\n     */\n  }, {\n    key: \"handle\",\n    value: function handle(args) {\n      for (var i = 0; i < this._cases.length; i++) {\n        var c = this._cases[i];\n        if (this._argsMatchTypes(args, c.types)) {\n          return c.handler.apply(null, args);\n        }\n      }\n      throw new Error(\"\".concat(this._name, \": Invalid arguments.\"));\n    }\n    /**\n     * Check if the arguments match the given types.\n     * @param {Arguments} args - The arguments.\n     * @param {Array.<string>} types - The types.\n     * @returns {boolean} True if matches, false otherwise.\n     * @throws {Error} Throws if unknown type.\n     * @private\n     */\n  }, {\n    key: \"_argsMatchTypes\",\n    value: function _argsMatchTypes(args, types) {\n      if (args.length !== types.length) return false;\n      return _.every(args, function (arg, i) {\n        var type = types[i];\n        if (type === '*') return true;\n        if (type === 'nil') return _.isNil(arg);\n        if (type === 'string') return typeof arg === \"string\";\n        if (type === 'boolean') return typeof arg === \"boolean\";\n        if (type === 'number') return typeof arg === \"number\";\n        if (type === 'integer') return typeof arg === \"number\" && _.isInteger(arg);\n        if (type === 'function') return typeof arg === \"function\";\n        if (type === 'array') return Array.isArray(arg);\n        if (type === 'date') return arg && arg.constructor === Date;\n        if (type === 'object') return arg && arg.constructor === Object;\n        if (arg && arg.constructor && arg.constructor.name === type) return true;\n        throw new Error(\"Unknown type: \".concat(type));\n      });\n    }\n  }]);\n  return ArgHandler;\n}();\nmodule.exports = ArgHandler;","map":null,"metadata":{},"sourceType":"script"}
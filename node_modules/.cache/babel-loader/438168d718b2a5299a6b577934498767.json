{"ast":null,"code":"/* cfb.js (C) 2013-present SheetJS -- http://sheetjs.com */\n/* vim: set ts=2: */\n/*jshint eqnull:true */\n/*exported CFB */\n/*global module, require:false, process:false, Buffer:false, Uint8Array:false, Uint16Array:false */\n\nvar Base64_map = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nfunction Base64_encode(input) {\n  var o = \"\";\n  var c1 = 0,\n    c2 = 0,\n    c3 = 0,\n    e1 = 0,\n    e2 = 0,\n    e3 = 0,\n    e4 = 0;\n  for (var i = 0; i < input.length;) {\n    c1 = input.charCodeAt(i++);\n    e1 = c1 >> 2;\n    c2 = input.charCodeAt(i++);\n    e2 = (c1 & 3) << 4 | c2 >> 4;\n    c3 = input.charCodeAt(i++);\n    e3 = (c2 & 15) << 2 | c3 >> 6;\n    e4 = c3 & 63;\n    if (isNaN(c2)) e3 = e4 = 64;else if (isNaN(c3)) e4 = 64;\n    o += Base64_map.charAt(e1) + Base64_map.charAt(e2) + Base64_map.charAt(e3) + Base64_map.charAt(e4);\n  }\n  return o;\n}\nfunction Base64_decode(input) {\n  var o = \"\";\n  var c1 = 0,\n    c2 = 0,\n    c3 = 0,\n    e1 = 0,\n    e2 = 0,\n    e3 = 0,\n    e4 = 0;\n  input = input.replace(/[^\\w\\+\\/\\=]/g, \"\");\n  for (var i = 0; i < input.length;) {\n    e1 = Base64_map.indexOf(input.charAt(i++));\n    e2 = Base64_map.indexOf(input.charAt(i++));\n    c1 = e1 << 2 | e2 >> 4;\n    o += String.fromCharCode(c1);\n    e3 = Base64_map.indexOf(input.charAt(i++));\n    c2 = (e2 & 15) << 4 | e3 >> 2;\n    if (e3 !== 64) o += String.fromCharCode(c2);\n    e4 = Base64_map.indexOf(input.charAt(i++));\n    c3 = (e3 & 3) << 6 | e4;\n    if (e4 !== 64) o += String.fromCharCode(c3);\n  }\n  return o;\n}\nvar has_buf = function () {\n  return typeof Buffer !== 'undefined' && typeof process !== 'undefined' && typeof process.versions !== 'undefined' && !!process.versions.node;\n}();\nvar Buffer_from = function () {\n  if (typeof Buffer !== 'undefined') {\n    var nbfs = !Buffer.from;\n    if (!nbfs) try {\n      Buffer.from(\"foo\", \"utf8\");\n    } catch (e) {\n      nbfs = true;\n    }\n    return nbfs ? function (buf, enc) {\n      return enc ? new Buffer(buf, enc) : new Buffer(buf);\n    } : Buffer.from.bind(Buffer);\n  }\n  return function () {};\n}();\nfunction new_raw_buf(len) {\n  /* jshint -W056 */\n  if (has_buf) {\n    if (Buffer.alloc) return Buffer.alloc(len);\n    var b = new Buffer(len);\n    b.fill(0);\n    return b;\n  }\n  return typeof Uint8Array != \"undefined\" ? new Uint8Array(len) : new Array(len);\n  /* jshint +W056 */\n}\n\nfunction new_unsafe_buf(len) {\n  /* jshint -W056 */\n  if (has_buf) return Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : new Buffer(len);\n  return typeof Uint8Array != \"undefined\" ? new Uint8Array(len) : new Array(len);\n  /* jshint +W056 */\n}\n\nvar s2a = function s2a(s) {\n  if (has_buf) return Buffer_from(s, \"binary\");\n  return s.split(\"\").map(function (x) {\n    return x.charCodeAt(0) & 0xff;\n  });\n};\nvar chr0 = /\\u0000/g,\n  chr1 = /[\\u0001-\\u0006]/g;\nvar __toBuffer = function __toBuffer(bufs) {\n  var x = [];\n  for (var i = 0; i < bufs[0].length; ++i) {\n    x.push.apply(x, bufs[0][i]);\n  }\n  return x;\n};\nvar ___toBuffer = __toBuffer;\nvar __utf16le = function __utf16le(b, s, e) {\n  var ss = [];\n  for (var i = s; i < e; i += 2) ss.push(String.fromCharCode(__readUInt16LE(b, i)));\n  return ss.join(\"\").replace(chr0, '');\n};\nvar ___utf16le = __utf16le;\nvar __hexlify = function __hexlify(b, s, l) {\n  var ss = [];\n  for (var i = s; i < s + l; ++i) ss.push((\"0\" + b[i].toString(16)).slice(-2));\n  return ss.join(\"\");\n};\nvar ___hexlify = __hexlify;\nvar __bconcat = function __bconcat(bufs) {\n  if (Array.isArray(bufs[0])) return [].concat.apply([], bufs);\n  var maxlen = 0,\n    i = 0;\n  for (i = 0; i < bufs.length; ++i) maxlen += bufs[i].length;\n  var o = new Uint8Array(maxlen);\n  for (i = 0, maxlen = 0; i < bufs.length; maxlen += bufs[i].length, ++i) o.set(bufs[i], maxlen);\n  return o;\n};\nvar bconcat = __bconcat;\nif (has_buf) {\n  __utf16le = function __utf16le(b, s, e) {\n    if (!Buffer.isBuffer(b)) return ___utf16le(b, s, e);\n    return b.toString('utf16le', s, e).replace(chr0, '') /*.replace(chr1,'!')*/;\n  };\n\n  __hexlify = function __hexlify(b, s, l) {\n    return Buffer.isBuffer(b) ? b.toString('hex', s, s + l) : ___hexlify(b, s, l);\n  };\n  __toBuffer = function __toBuffer(bufs) {\n    return bufs[0].length > 0 && Buffer.isBuffer(bufs[0][0]) ? Buffer.concat(bufs[0]) : ___toBuffer(bufs);\n  };\n  s2a = function s2a(s) {\n    return Buffer_from(s, \"binary\");\n  };\n  bconcat = function bconcat(bufs) {\n    return Buffer.isBuffer(bufs[0]) ? Buffer.concat(bufs) : __bconcat(bufs);\n  };\n}\nvar __readUInt8 = function __readUInt8(b, idx) {\n  return b[idx];\n};\nvar __readUInt16LE = function __readUInt16LE(b, idx) {\n  return b[idx + 1] * (1 << 8) + b[idx];\n};\nvar __readInt16LE = function __readInt16LE(b, idx) {\n  var u = b[idx + 1] * (1 << 8) + b[idx];\n  return u < 0x8000 ? u : (0xffff - u + 1) * -1;\n};\nvar __readUInt32LE = function __readUInt32LE(b, idx) {\n  return b[idx + 3] * (1 << 24) + (b[idx + 2] << 16) + (b[idx + 1] << 8) + b[idx];\n};\nvar __readInt32LE = function __readInt32LE(b, idx) {\n  return (b[idx + 3] << 24) + (b[idx + 2] << 16) + (b[idx + 1] << 8) + b[idx];\n};\nfunction ReadShift(size, t) {\n  var oI,\n    oS,\n    type = 0;\n  switch (size) {\n    case 1:\n      oI = __readUInt8(this, this.l);\n      break;\n    case 2:\n      oI = (t !== 'i' ? __readUInt16LE : __readInt16LE)(this, this.l);\n      break;\n    case 4:\n      oI = __readInt32LE(this, this.l);\n      break;\n    case 16:\n      type = 2;\n      oS = __hexlify(this, this.l, size);\n  }\n  this.l += size;\n  if (type === 0) return oI;\n  return oS;\n}\nvar __writeUInt32LE = function __writeUInt32LE(b, val, idx) {\n  b[idx] = val & 0xFF;\n  b[idx + 1] = val >>> 8 & 0xFF;\n  b[idx + 2] = val >>> 16 & 0xFF;\n  b[idx + 3] = val >>> 24 & 0xFF;\n};\nvar __writeInt32LE = function __writeInt32LE(b, val, idx) {\n  b[idx] = val & 0xFF;\n  b[idx + 1] = val >> 8 & 0xFF;\n  b[idx + 2] = val >> 16 & 0xFF;\n  b[idx + 3] = val >> 24 & 0xFF;\n};\nfunction WriteShift(t, val, f) {\n  var size = 0,\n    i = 0;\n  switch (f) {\n    case \"hex\":\n      for (; i < t; ++i) {\n        this[this.l++] = parseInt(val.slice(2 * i, 2 * i + 2), 16) || 0;\n      }\n      return this;\n    case \"utf16le\":\n      var end = this.l + t;\n      for (i = 0; i < Math.min(val.length, t); ++i) {\n        var cc = val.charCodeAt(i);\n        this[this.l++] = cc & 0xff;\n        this[this.l++] = cc >> 8;\n      }\n      while (this.l < end) this[this.l++] = 0;\n      return this;\n  }\n  switch (t) {\n    case 1:\n      size = 1;\n      this[this.l] = val & 0xFF;\n      break;\n    case 2:\n      size = 2;\n      this[this.l] = val & 0xFF;\n      val >>>= 8;\n      this[this.l + 1] = val & 0xFF;\n      break;\n    case 4:\n      size = 4;\n      __writeUInt32LE(this, val, this.l);\n      break;\n    case -4:\n      size = 4;\n      __writeInt32LE(this, val, this.l);\n      break;\n  }\n  this.l += size;\n  return this;\n}\nfunction CheckField(hexstr, fld) {\n  var m = __hexlify(this, this.l, hexstr.length >> 1);\n  if (m !== hexstr) throw new Error(fld + 'Expected ' + hexstr + ' saw ' + m);\n  this.l += hexstr.length >> 1;\n}\nfunction prep_blob(blob, pos) {\n  blob.l = pos;\n  blob.read_shift = ReadShift;\n  blob.chk = CheckField;\n  blob.write_shift = WriteShift;\n}\nfunction new_buf(sz) {\n  var o = new_raw_buf(sz);\n  prep_blob(o, 0);\n  return o;\n}\n\n/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */\n/* vim: set ts=2: */\n/*exported CRC32 */\nvar CRC32 = function () {\n  var CRC32 = {};\n  CRC32.version = '1.2.1';\n  /*global Int32Array */\n  function signed_crc_table() {\n    var c = 0,\n      table = new Array(256);\n    for (var n = 0; n != 256; ++n) {\n      c = n;\n      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;\n      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;\n      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;\n      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;\n      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;\n      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;\n      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;\n      c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;\n      table[n] = c;\n    }\n    return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;\n  }\n  var T0 = signed_crc_table();\n  function slice_by_16_tables(T) {\n    var c = 0,\n      v = 0,\n      n = 0,\n      table = typeof Int32Array !== 'undefined' ? new Int32Array(4096) : new Array(4096);\n    for (n = 0; n != 256; ++n) table[n] = T[n];\n    for (n = 0; n != 256; ++n) {\n      v = T[n];\n      for (c = 256 + n; c < 4096; c += 256) v = table[c] = v >>> 8 ^ T[v & 0xFF];\n    }\n    var out = [];\n    for (n = 1; n != 16; ++n) out[n - 1] = typeof Int32Array !== 'undefined' ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);\n    return out;\n  }\n  var TT = slice_by_16_tables(T0);\n  var T1 = TT[0],\n    T2 = TT[1],\n    T3 = TT[2],\n    T4 = TT[3],\n    T5 = TT[4];\n  var T6 = TT[5],\n    T7 = TT[6],\n    T8 = TT[7],\n    T9 = TT[8],\n    Ta = TT[9];\n  var Tb = TT[10],\n    Tc = TT[11],\n    Td = TT[12],\n    Te = TT[13],\n    Tf = TT[14];\n  function crc32_bstr(bstr, seed) {\n    var C = seed ^ -1;\n    for (var i = 0, L = bstr.length; i < L;) C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 0xFF];\n    return ~C;\n  }\n  function crc32_buf(B, seed) {\n    var C = seed ^ -1,\n      L = B.length - 15,\n      i = 0;\n    for (; i < L;) C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];\n    L += 15;\n    while (i < L) C = C >>> 8 ^ T0[(C ^ B[i++]) & 0xFF];\n    return ~C;\n  }\n  function crc32_str(str, seed) {\n    var C = seed ^ -1;\n    for (var i = 0, L = str.length, c = 0, d = 0; i < L;) {\n      c = str.charCodeAt(i++);\n      if (c < 0x80) {\n        C = C >>> 8 ^ T0[(C ^ c) & 0xFF];\n      } else if (c < 0x800) {\n        C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 0xFF];\n        C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 0xFF];\n      } else if (c >= 0xD800 && c < 0xE000) {\n        c = (c & 1023) + 64;\n        d = str.charCodeAt(i++) & 1023;\n        C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 0xFF];\n        C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 0xFF];\n        C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 0xFF];\n        C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 0xFF];\n      } else {\n        C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 0xFF];\n        C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 0xFF];\n        C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 0xFF];\n      }\n    }\n    return ~C;\n  }\n  CRC32.table = T0;\n  CRC32.bstr = crc32_bstr;\n  CRC32.buf = crc32_buf;\n  CRC32.str = crc32_str;\n  return CRC32;\n}();\n/* [MS-CFB] v20171201 */\nvar CFB = function _CFB() {\n  var exports = {};\n  exports.version = '1.2.2';\n  /* [MS-CFB] 2.6.4 */\n  function namecmp(l, r) {\n    var L = l.split(\"/\"),\n      R = r.split(\"/\");\n    for (var i = 0, c = 0, Z = Math.min(L.length, R.length); i < Z; ++i) {\n      if (c = L[i].length - R[i].length) return c;\n      if (L[i] != R[i]) return L[i] < R[i] ? -1 : 1;\n    }\n    return L.length - R.length;\n  }\n  function dirname(p) {\n    if (p.charAt(p.length - 1) == \"/\") return p.slice(0, -1).indexOf(\"/\") === -1 ? p : dirname(p.slice(0, -1));\n    var c = p.lastIndexOf(\"/\");\n    return c === -1 ? p : p.slice(0, c + 1);\n  }\n  function filename(p) {\n    if (p.charAt(p.length - 1) == \"/\") return filename(p.slice(0, -1));\n    var c = p.lastIndexOf(\"/\");\n    return c === -1 ? p : p.slice(c + 1);\n  }\n  /* -------------------------------------------------------------------------- */\n  /* DOS Date format:\n     high|YYYYYYYm.mmmddddd.HHHHHMMM.MMMSSSSS|low\n     add 1980 to stored year\n     stored second should be doubled\n  */\n\n  /* write JS date to buf as a DOS date */\n  function write_dos_date(buf, date) {\n    if (typeof date === \"string\") date = new Date(date);\n    var hms = date.getHours();\n    hms = hms << 6 | date.getMinutes();\n    hms = hms << 5 | date.getSeconds() >>> 1;\n    buf.write_shift(2, hms);\n    var ymd = date.getFullYear() - 1980;\n    ymd = ymd << 4 | date.getMonth() + 1;\n    ymd = ymd << 5 | date.getDate();\n    buf.write_shift(2, ymd);\n  }\n\n  /* read four bytes from buf and interpret as a DOS date */\n  function parse_dos_date(buf) {\n    var hms = buf.read_shift(2) & 0xFFFF;\n    var ymd = buf.read_shift(2) & 0xFFFF;\n    var val = new Date();\n    var d = ymd & 0x1F;\n    ymd >>>= 5;\n    var m = ymd & 0x0F;\n    ymd >>>= 4;\n    val.setMilliseconds(0);\n    val.setFullYear(ymd + 1980);\n    val.setMonth(m - 1);\n    val.setDate(d);\n    var S = hms & 0x1F;\n    hms >>>= 5;\n    var M = hms & 0x3F;\n    hms >>>= 6;\n    val.setHours(hms);\n    val.setMinutes(M);\n    val.setSeconds(S << 1);\n    return val;\n  }\n  function parse_extra_field(blob) {\n    prep_blob(blob, 0);\n    var o = {};\n    var flags = 0;\n    while (blob.l <= blob.length - 4) {\n      var type = blob.read_shift(2);\n      var sz = blob.read_shift(2),\n        tgt = blob.l + sz;\n      var p = {};\n      switch (type) {\n        /* UNIX-style Timestamps */\n        case 0x5455:\n          {\n            flags = blob.read_shift(1);\n            if (flags & 1) p.mtime = blob.read_shift(4);\n            /* for some reason, CD flag corresponds to LFH */\n            if (sz > 5) {\n              if (flags & 2) p.atime = blob.read_shift(4);\n              if (flags & 4) p.ctime = blob.read_shift(4);\n            }\n            if (p.mtime) p.mt = new Date(p.mtime * 1000);\n          }\n          break;\n      }\n      blob.l = tgt;\n      o[type] = p;\n    }\n    return o;\n  }\n  var fs;\n  function get_fs() {\n    return fs || (fs = require('fs'));\n  }\n  function parse(file, options) {\n    if (file[0] == 0x50 && file[1] == 0x4b) return parse_zip(file, options);\n    if ((file[0] | 0x20) == 0x6d && (file[1] | 0x20) == 0x69) return parse_mad(file, options);\n    if (file.length < 512) throw new Error(\"CFB file size \" + file.length + \" < 512\");\n    var mver = 3;\n    var ssz = 512;\n    var nmfs = 0; // number of mini FAT sectors\n    var difat_sec_cnt = 0;\n    var dir_start = 0;\n    var minifat_start = 0;\n    var difat_start = 0;\n    var fat_addrs = []; // locations of FAT sectors\n\n    /* [MS-CFB] 2.2 Compound File Header */\n    var blob = file.slice(0, 512);\n    prep_blob(blob, 0);\n\n    /* major version */\n    var mv = check_get_mver(blob);\n    mver = mv[0];\n    switch (mver) {\n      case 3:\n        ssz = 512;\n        break;\n      case 4:\n        ssz = 4096;\n        break;\n      case 0:\n        if (mv[1] == 0) return parse_zip(file, options);\n      /* falls through */\n      default:\n        throw new Error(\"Major Version: Expected 3 or 4 saw \" + mver);\n    }\n\n    /* reprocess header */\n    if (ssz !== 512) {\n      blob = file.slice(0, ssz);\n      prep_blob(blob, 28 /* blob.l */);\n    }\n    /* Save header for final object */\n    var header = file.slice(0, ssz);\n    check_shifts(blob, mver);\n\n    // Number of Directory Sectors\n    var dir_cnt = blob.read_shift(4, 'i');\n    if (mver === 3 && dir_cnt !== 0) throw new Error('# Directory Sectors: Expected 0 saw ' + dir_cnt);\n\n    // Number of FAT Sectors\n    blob.l += 4;\n\n    // First Directory Sector Location\n    dir_start = blob.read_shift(4, 'i');\n\n    // Transaction Signature\n    blob.l += 4;\n\n    // Mini Stream Cutoff Size\n    blob.chk('00100000', 'Mini Stream Cutoff Size: ');\n\n    // First Mini FAT Sector Location\n    minifat_start = blob.read_shift(4, 'i');\n\n    // Number of Mini FAT Sectors\n    nmfs = blob.read_shift(4, 'i');\n\n    // First DIFAT sector location\n    difat_start = blob.read_shift(4, 'i');\n\n    // Number of DIFAT Sectors\n    difat_sec_cnt = blob.read_shift(4, 'i');\n\n    // Grab FAT Sector Locations\n    for (var q = -1, j = 0; j < 109; ++j) {\n      /* 109 = (512 - blob.l)>>>2; */\n      q = blob.read_shift(4, 'i');\n      if (q < 0) break;\n      fat_addrs[j] = q;\n    }\n\n    /** Break the file up into sectors */\n    var sectors = sectorify(file, ssz);\n    sleuth_fat(difat_start, difat_sec_cnt, sectors, ssz, fat_addrs);\n\n    /** Chains */\n    var sector_list = make_sector_list(sectors, dir_start, fat_addrs, ssz);\n    sector_list[dir_start].name = \"!Directory\";\n    if (nmfs > 0 && minifat_start !== ENDOFCHAIN) sector_list[minifat_start].name = \"!MiniFAT\";\n    sector_list[fat_addrs[0]].name = \"!FAT\";\n    sector_list.fat_addrs = fat_addrs;\n    sector_list.ssz = ssz;\n\n    /* [MS-CFB] 2.6.1 Compound File Directory Entry */\n    var files = {},\n      Paths = [],\n      FileIndex = [],\n      FullPaths = [];\n    read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, minifat_start);\n    build_full_paths(FileIndex, FullPaths, Paths);\n    Paths.shift();\n    var o = {\n      FileIndex: FileIndex,\n      FullPaths: FullPaths\n    };\n\n    // $FlowIgnore\n    if (options && options.raw) o.raw = {\n      header: header,\n      sectors: sectors\n    };\n    return o;\n  } // parse\n\n  /* [MS-CFB] 2.2 Compound File Header -- read up to major version */\n  function check_get_mver(blob) {\n    if (blob[blob.l] == 0x50 && blob[blob.l + 1] == 0x4b) return [0, 0];\n    // header signature 8\n    blob.chk(HEADER_SIGNATURE, 'Header Signature: ');\n\n    // clsid 16\n    //blob.chk(HEADER_CLSID, 'CLSID: ');\n    blob.l += 16;\n\n    // minor version 2\n    var mver = blob.read_shift(2, 'u');\n    return [blob.read_shift(2, 'u'), mver];\n  }\n  function check_shifts(blob, mver) {\n    var shift = 0x09;\n\n    // Byte Order\n    //blob.chk('feff', 'Byte Order: '); // note: some writers put 0xffff\n    blob.l += 2;\n\n    // Sector Shift\n    switch (shift = blob.read_shift(2)) {\n      case 0x09:\n        if (mver != 3) throw new Error('Sector Shift: Expected 9 saw ' + shift);\n        break;\n      case 0x0c:\n        if (mver != 4) throw new Error('Sector Shift: Expected 12 saw ' + shift);\n        break;\n      default:\n        throw new Error('Sector Shift: Expected 9 or 12 saw ' + shift);\n    }\n\n    // Mini Sector Shift\n    blob.chk('0600', 'Mini Sector Shift: ');\n\n    // Reserved\n    blob.chk('000000000000', 'Reserved: ');\n  }\n\n  /** Break the file up into sectors */\n  function sectorify(file, ssz) {\n    var nsectors = Math.ceil(file.length / ssz) - 1;\n    var sectors = [];\n    for (var i = 1; i < nsectors; ++i) sectors[i - 1] = file.slice(i * ssz, (i + 1) * ssz);\n    sectors[nsectors - 1] = file.slice(nsectors * ssz);\n    return sectors;\n  }\n\n  /* [MS-CFB] 2.6.4 Red-Black Tree */\n  function build_full_paths(FI, FP, Paths) {\n    var i = 0,\n      L = 0,\n      R = 0,\n      C = 0,\n      j = 0,\n      pl = Paths.length;\n    var dad = [],\n      q = [];\n    for (; i < pl; ++i) {\n      dad[i] = q[i] = i;\n      FP[i] = Paths[i];\n    }\n    for (; j < q.length; ++j) {\n      i = q[j];\n      L = FI[i].L;\n      R = FI[i].R;\n      C = FI[i].C;\n      if (dad[i] === i) {\n        if (L !== -1 /*NOSTREAM*/ && dad[L] !== L) dad[i] = dad[L];\n        if (R !== -1 && dad[R] !== R) dad[i] = dad[R];\n      }\n      if (C !== -1 /*NOSTREAM*/) dad[C] = i;\n      if (L !== -1 && i != dad[i]) {\n        dad[L] = dad[i];\n        if (q.lastIndexOf(L) < j) q.push(L);\n      }\n      if (R !== -1 && i != dad[i]) {\n        dad[R] = dad[i];\n        if (q.lastIndexOf(R) < j) q.push(R);\n      }\n    }\n    for (i = 1; i < pl; ++i) if (dad[i] === i) {\n      if (R !== -1 /*NOSTREAM*/ && dad[R] !== R) dad[i] = dad[R];else if (L !== -1 && dad[L] !== L) dad[i] = dad[L];\n    }\n    for (i = 1; i < pl; ++i) {\n      if (FI[i].type === 0 /* unknown */) continue;\n      j = i;\n      if (j != dad[j]) do {\n        j = dad[j];\n        FP[i] = FP[j] + \"/\" + FP[i];\n      } while (j !== 0 && -1 !== dad[j] && j != dad[j]);\n      dad[i] = -1;\n    }\n    FP[0] += \"/\";\n    for (i = 1; i < pl; ++i) {\n      if (FI[i].type !== 2 /* stream */) FP[i] += \"/\";\n    }\n  }\n  function get_mfat_entry(entry, payload, mini) {\n    var start = entry.start,\n      size = entry.size;\n    //return (payload.slice(start*MSSZ, start*MSSZ + size));\n    var o = [];\n    var idx = start;\n    while (mini && size > 0 && idx >= 0) {\n      o.push(payload.slice(idx * MSSZ, idx * MSSZ + MSSZ));\n      size -= MSSZ;\n      idx = __readInt32LE(mini, idx * 4);\n    }\n    if (o.length === 0) return new_buf(0);\n    return bconcat(o).slice(0, entry.size);\n  }\n\n  /** Chase down the rest of the DIFAT chain to build a comprehensive list\n      DIFAT chains by storing the next sector number as the last 32 bits */\n  function sleuth_fat(idx, cnt, sectors, ssz, fat_addrs) {\n    var q = ENDOFCHAIN;\n    if (idx === ENDOFCHAIN) {\n      if (cnt !== 0) throw new Error(\"DIFAT chain shorter than expected\");\n    } else if (idx !== -1 /*FREESECT*/) {\n      var sector = sectors[idx],\n        m = (ssz >>> 2) - 1;\n      if (!sector) return;\n      for (var i = 0; i < m; ++i) {\n        if ((q = __readInt32LE(sector, i * 4)) === ENDOFCHAIN) break;\n        fat_addrs.push(q);\n      }\n      if (cnt >= 1) sleuth_fat(__readInt32LE(sector, ssz - 4), cnt - 1, sectors, ssz, fat_addrs);\n    }\n  }\n\n  /** Follow the linked list of sectors for a given starting point */\n  function get_sector_list(sectors, start, fat_addrs, ssz, chkd) {\n    var buf = [],\n      buf_chain = [];\n    if (!chkd) chkd = [];\n    var modulus = ssz - 1,\n      j = 0,\n      jj = 0;\n    for (j = start; j >= 0;) {\n      chkd[j] = true;\n      buf[buf.length] = j;\n      buf_chain.push(sectors[j]);\n      var addr = fat_addrs[Math.floor(j * 4 / ssz)];\n      jj = j * 4 & modulus;\n      if (ssz < 4 + jj) throw new Error(\"FAT boundary crossed: \" + j + \" 4 \" + ssz);\n      if (!sectors[addr]) break;\n      j = __readInt32LE(sectors[addr], jj);\n    }\n    return {\n      nodes: buf,\n      data: __toBuffer([buf_chain])\n    };\n  }\n\n  /** Chase down the sector linked lists */\n  function make_sector_list(sectors, dir_start, fat_addrs, ssz) {\n    var sl = sectors.length,\n      sector_list = [];\n    var chkd = [],\n      buf = [],\n      buf_chain = [];\n    var modulus = ssz - 1,\n      i = 0,\n      j = 0,\n      k = 0,\n      jj = 0;\n    for (i = 0; i < sl; ++i) {\n      buf = [];\n      k = i + dir_start;\n      if (k >= sl) k -= sl;\n      if (chkd[k]) continue;\n      buf_chain = [];\n      var seen = [];\n      for (j = k; j >= 0;) {\n        seen[j] = true;\n        chkd[j] = true;\n        buf[buf.length] = j;\n        buf_chain.push(sectors[j]);\n        var addr = fat_addrs[Math.floor(j * 4 / ssz)];\n        jj = j * 4 & modulus;\n        if (ssz < 4 + jj) throw new Error(\"FAT boundary crossed: \" + j + \" 4 \" + ssz);\n        if (!sectors[addr]) break;\n        j = __readInt32LE(sectors[addr], jj);\n        if (seen[j]) break;\n      }\n      sector_list[k] = {\n        nodes: buf,\n        data: __toBuffer([buf_chain])\n      };\n    }\n    return sector_list;\n  }\n\n  /* [MS-CFB] 2.6.1 Compound File Directory Entry */\n  function read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, mini) {\n    var minifat_store = 0,\n      pl = Paths.length ? 2 : 0;\n    var sector = sector_list[dir_start].data;\n    var i = 0,\n      namelen = 0,\n      name;\n    for (; i < sector.length; i += 128) {\n      var blob = sector.slice(i, i + 128);\n      prep_blob(blob, 64);\n      namelen = blob.read_shift(2);\n      name = __utf16le(blob, 0, namelen - pl);\n      Paths.push(name);\n      var o = {\n        name: name,\n        type: blob.read_shift(1),\n        color: blob.read_shift(1),\n        L: blob.read_shift(4, 'i'),\n        R: blob.read_shift(4, 'i'),\n        C: blob.read_shift(4, 'i'),\n        clsid: blob.read_shift(16),\n        state: blob.read_shift(4, 'i'),\n        start: 0,\n        size: 0\n      };\n      var ctime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);\n      if (ctime !== 0) o.ct = read_date(blob, blob.l - 8);\n      var mtime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);\n      if (mtime !== 0) o.mt = read_date(blob, blob.l - 8);\n      o.start = blob.read_shift(4, 'i');\n      o.size = blob.read_shift(4, 'i');\n      if (o.size < 0 && o.start < 0) {\n        o.size = o.type = 0;\n        o.start = ENDOFCHAIN;\n        o.name = \"\";\n      }\n      if (o.type === 5) {\n        /* root */\n        minifat_store = o.start;\n        if (nmfs > 0 && minifat_store !== ENDOFCHAIN) sector_list[minifat_store].name = \"!StreamData\";\n        /*minifat_size = o.size;*/\n      } else if (o.size >= 4096 /* MSCSZ */) {\n        o.storage = 'fat';\n        if (sector_list[o.start] === undefined) sector_list[o.start] = get_sector_list(sectors, o.start, sector_list.fat_addrs, sector_list.ssz);\n        sector_list[o.start].name = o.name;\n        o.content = sector_list[o.start].data.slice(0, o.size);\n      } else {\n        o.storage = 'minifat';\n        if (o.size < 0) o.size = 0;else if (minifat_store !== ENDOFCHAIN && o.start !== ENDOFCHAIN && sector_list[minifat_store]) {\n          o.content = get_mfat_entry(o, sector_list[minifat_store].data, (sector_list[mini] || {}).data);\n        }\n      }\n      if (o.content) prep_blob(o.content, 0);\n      files[name] = o;\n      FileIndex.push(o);\n    }\n  }\n  function read_date(blob, offset) {\n    return new Date((__readUInt32LE(blob, offset + 4) / 1e7 * Math.pow(2, 32) + __readUInt32LE(blob, offset) / 1e7 - 11644473600) * 1000);\n  }\n  function read_file(filename, options) {\n    get_fs();\n    return parse(fs.readFileSync(filename), options);\n  }\n  function read(blob, options) {\n    var type = options && options.type;\n    if (!type) {\n      if (has_buf && Buffer.isBuffer(blob)) type = \"buffer\";\n    }\n    switch (type || \"base64\") {\n      case \"file\":\n        return read_file(blob, options);\n      case \"base64\":\n        return parse(s2a(Base64_decode(blob)), options);\n      case \"binary\":\n        return parse(s2a(blob), options);\n    }\n    return parse(blob, options);\n  }\n  function init_cfb(cfb, opts) {\n    var o = opts || {},\n      root = o.root || \"Root Entry\";\n    if (!cfb.FullPaths) cfb.FullPaths = [];\n    if (!cfb.FileIndex) cfb.FileIndex = [];\n    if (cfb.FullPaths.length !== cfb.FileIndex.length) throw new Error(\"inconsistent CFB structure\");\n    if (cfb.FullPaths.length === 0) {\n      cfb.FullPaths[0] = root + \"/\";\n      cfb.FileIndex[0] = {\n        name: root,\n        type: 5\n      };\n    }\n    if (o.CLSID) cfb.FileIndex[0].clsid = o.CLSID;\n    seed_cfb(cfb);\n  }\n  function seed_cfb(cfb) {\n    var nm = \"\\x01Sh33tJ5\";\n    if (CFB.find(cfb, \"/\" + nm)) return;\n    var p = new_buf(4);\n    p[0] = 55;\n    p[1] = p[3] = 50;\n    p[2] = 54;\n    cfb.FileIndex.push({\n      name: nm,\n      type: 2,\n      content: p,\n      size: 4,\n      L: 69,\n      R: 69,\n      C: 69\n    });\n    cfb.FullPaths.push(cfb.FullPaths[0] + nm);\n    rebuild_cfb(cfb);\n  }\n  function rebuild_cfb(cfb, f) {\n    init_cfb(cfb);\n    var gc = false,\n      s = false;\n    for (var i = cfb.FullPaths.length - 1; i >= 0; --i) {\n      var _file = cfb.FileIndex[i];\n      switch (_file.type) {\n        case 0:\n          if (s) gc = true;else {\n            cfb.FileIndex.pop();\n            cfb.FullPaths.pop();\n          }\n          break;\n        case 1:\n        case 2:\n        case 5:\n          s = true;\n          if (isNaN(_file.R * _file.L * _file.C)) gc = true;\n          if (_file.R > -1 && _file.L > -1 && _file.R == _file.L) gc = true;\n          break;\n        default:\n          gc = true;\n          break;\n      }\n    }\n    if (!gc && !f) return;\n    var now = new Date(1987, 1, 19),\n      j = 0;\n    // Track which names exist\n    var fullPaths = Object.create ? Object.create(null) : {};\n    var data = [];\n    for (i = 0; i < cfb.FullPaths.length; ++i) {\n      fullPaths[cfb.FullPaths[i]] = true;\n      if (cfb.FileIndex[i].type === 0) continue;\n      data.push([cfb.FullPaths[i], cfb.FileIndex[i]]);\n    }\n    for (i = 0; i < data.length; ++i) {\n      var dad = dirname(data[i][0]);\n      s = fullPaths[dad];\n      while (!s) {\n        while (dirname(dad) && !fullPaths[dirname(dad)]) dad = dirname(dad);\n        data.push([dad, {\n          name: filename(dad).replace(\"/\", \"\"),\n          type: 1,\n          clsid: HEADER_CLSID,\n          ct: now,\n          mt: now,\n          content: null\n        }]);\n\n        // Add name to set\n        fullPaths[dad] = true;\n        dad = dirname(data[i][0]);\n        s = fullPaths[dad];\n      }\n    }\n    data.sort(function (x, y) {\n      return namecmp(x[0], y[0]);\n    });\n    cfb.FullPaths = [];\n    cfb.FileIndex = [];\n    for (i = 0; i < data.length; ++i) {\n      cfb.FullPaths[i] = data[i][0];\n      cfb.FileIndex[i] = data[i][1];\n    }\n    for (i = 0; i < data.length; ++i) {\n      var elt = cfb.FileIndex[i];\n      var nm = cfb.FullPaths[i];\n      elt.name = filename(nm).replace(\"/\", \"\");\n      elt.L = elt.R = elt.C = -(elt.color = 1);\n      elt.size = elt.content ? elt.content.length : 0;\n      elt.start = 0;\n      elt.clsid = elt.clsid || HEADER_CLSID;\n      if (i === 0) {\n        elt.C = data.length > 1 ? 1 : -1;\n        elt.size = 0;\n        elt.type = 5;\n      } else if (nm.slice(-1) == \"/\") {\n        for (j = i + 1; j < data.length; ++j) if (dirname(cfb.FullPaths[j]) == nm) break;\n        elt.C = j >= data.length ? -1 : j;\n        for (j = i + 1; j < data.length; ++j) if (dirname(cfb.FullPaths[j]) == dirname(nm)) break;\n        elt.R = j >= data.length ? -1 : j;\n        elt.type = 1;\n      } else {\n        if (dirname(cfb.FullPaths[i + 1] || \"\") == dirname(nm)) elt.R = i + 1;\n        elt.type = 2;\n      }\n    }\n  }\n  function _write(cfb, options) {\n    var _opts = options || {};\n    /* MAD is order-sensitive, skip rebuild and sort */\n    if (_opts.fileType == 'mad') return write_mad(cfb, _opts);\n    rebuild_cfb(cfb);\n    switch (_opts.fileType) {\n      case 'zip':\n        return write_zip(cfb, _opts);\n      //case 'mad': return write_mad(cfb, _opts);\n    }\n\n    var L = function (cfb) {\n      var mini_size = 0,\n        fat_size = 0;\n      for (var i = 0; i < cfb.FileIndex.length; ++i) {\n        var file = cfb.FileIndex[i];\n        if (!file.content) continue;\n        var flen = file.content.length;\n        if (flen > 0) {\n          if (flen < 0x1000) mini_size += flen + 0x3F >> 6;else fat_size += flen + 0x01FF >> 9;\n        }\n      }\n      var dir_cnt = cfb.FullPaths.length + 3 >> 2;\n      var mini_cnt = mini_size + 7 >> 3;\n      var mfat_cnt = mini_size + 0x7F >> 7;\n      var fat_base = mini_cnt + fat_size + dir_cnt + mfat_cnt;\n      var fat_cnt = fat_base + 0x7F >> 7;\n      var difat_cnt = fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 0x7F);\n      while (fat_base + fat_cnt + difat_cnt + 0x7F >> 7 > fat_cnt) difat_cnt = ++fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 0x7F);\n      var L = [1, difat_cnt, fat_cnt, mfat_cnt, dir_cnt, fat_size, mini_size, 0];\n      cfb.FileIndex[0].size = mini_size << 6;\n      L[7] = (cfb.FileIndex[0].start = L[0] + L[1] + L[2] + L[3] + L[4] + L[5]) + (L[6] + 7 >> 3);\n      return L;\n    }(cfb);\n    var o = new_buf(L[7] << 9);\n    var i = 0,\n      T = 0;\n    {\n      for (i = 0; i < 8; ++i) o.write_shift(1, HEADER_SIG[i]);\n      for (i = 0; i < 8; ++i) o.write_shift(2, 0);\n      o.write_shift(2, 0x003E);\n      o.write_shift(2, 0x0003);\n      o.write_shift(2, 0xFFFE);\n      o.write_shift(2, 0x0009);\n      o.write_shift(2, 0x0006);\n      for (i = 0; i < 3; ++i) o.write_shift(2, 0);\n      o.write_shift(4, 0);\n      o.write_shift(4, L[2]);\n      o.write_shift(4, L[0] + L[1] + L[2] + L[3] - 1);\n      o.write_shift(4, 0);\n      o.write_shift(4, 1 << 12);\n      o.write_shift(4, L[3] ? L[0] + L[1] + L[2] - 1 : ENDOFCHAIN);\n      o.write_shift(4, L[3]);\n      o.write_shift(-4, L[1] ? L[0] - 1 : ENDOFCHAIN);\n      o.write_shift(4, L[1]);\n      for (i = 0; i < 109; ++i) o.write_shift(-4, i < L[2] ? L[1] + i : -1);\n    }\n    if (L[1]) {\n      for (T = 0; T < L[1]; ++T) {\n        for (; i < 236 + T * 127; ++i) o.write_shift(-4, i < L[2] ? L[1] + i : -1);\n        o.write_shift(-4, T === L[1] - 1 ? ENDOFCHAIN : T + 1);\n      }\n    }\n    var chainit = function chainit(w) {\n      for (T += w; i < T - 1; ++i) o.write_shift(-4, i + 1);\n      if (w) {\n        ++i;\n        o.write_shift(-4, ENDOFCHAIN);\n      }\n    };\n    T = i = 0;\n    for (T += L[1]; i < T; ++i) o.write_shift(-4, consts.DIFSECT);\n    for (T += L[2]; i < T; ++i) o.write_shift(-4, consts.FATSECT);\n    chainit(L[3]);\n    chainit(L[4]);\n    var j = 0,\n      flen = 0;\n    var file = cfb.FileIndex[0];\n    for (; j < cfb.FileIndex.length; ++j) {\n      file = cfb.FileIndex[j];\n      if (!file.content) continue;\n      flen = file.content.length;\n      if (flen < 0x1000) continue;\n      file.start = T;\n      chainit(flen + 0x01FF >> 9);\n    }\n    chainit(L[6] + 7 >> 3);\n    while (o.l & 0x1FF) o.write_shift(-4, consts.ENDOFCHAIN);\n    T = i = 0;\n    for (j = 0; j < cfb.FileIndex.length; ++j) {\n      file = cfb.FileIndex[j];\n      if (!file.content) continue;\n      flen = file.content.length;\n      if (!flen || flen >= 0x1000) continue;\n      file.start = T;\n      chainit(flen + 0x3F >> 6);\n    }\n    while (o.l & 0x1FF) o.write_shift(-4, consts.ENDOFCHAIN);\n    for (i = 0; i < L[4] << 2; ++i) {\n      var nm = cfb.FullPaths[i];\n      if (!nm || nm.length === 0) {\n        for (j = 0; j < 17; ++j) o.write_shift(4, 0);\n        for (j = 0; j < 3; ++j) o.write_shift(4, -1);\n        for (j = 0; j < 12; ++j) o.write_shift(4, 0);\n        continue;\n      }\n      file = cfb.FileIndex[i];\n      if (i === 0) file.start = file.size ? file.start - 1 : ENDOFCHAIN;\n      var _nm = i === 0 && _opts.root || file.name;\n      if (_nm.length > 32) {\n        console.error(\"Name \" + _nm + \" will be truncated to \" + _nm.slice(0, 32));\n        _nm = _nm.slice(0, 32);\n      }\n      flen = 2 * (_nm.length + 1);\n      o.write_shift(64, _nm, \"utf16le\");\n      o.write_shift(2, flen);\n      o.write_shift(1, file.type);\n      o.write_shift(1, file.color);\n      o.write_shift(-4, file.L);\n      o.write_shift(-4, file.R);\n      o.write_shift(-4, file.C);\n      if (!file.clsid) for (j = 0; j < 4; ++j) o.write_shift(4, 0);else o.write_shift(16, file.clsid, \"hex\");\n      o.write_shift(4, file.state || 0);\n      o.write_shift(4, 0);\n      o.write_shift(4, 0);\n      o.write_shift(4, 0);\n      o.write_shift(4, 0);\n      o.write_shift(4, file.start);\n      o.write_shift(4, file.size);\n      o.write_shift(4, 0);\n    }\n    for (i = 1; i < cfb.FileIndex.length; ++i) {\n      file = cfb.FileIndex[i];\n      if (file.size >= 0x1000) {\n        o.l = file.start + 1 << 9;\n        if (has_buf && Buffer.isBuffer(file.content)) {\n          file.content.copy(o, o.l, 0, file.size);\n          // o is a 0-filled Buffer so just set next offset\n          o.l += file.size + 511 & -512;\n        } else {\n          for (j = 0; j < file.size; ++j) o.write_shift(1, file.content[j]);\n          for (; j & 0x1FF; ++j) o.write_shift(1, 0);\n        }\n      }\n    }\n    for (i = 1; i < cfb.FileIndex.length; ++i) {\n      file = cfb.FileIndex[i];\n      if (file.size > 0 && file.size < 0x1000) {\n        if (has_buf && Buffer.isBuffer(file.content)) {\n          file.content.copy(o, o.l, 0, file.size);\n          // o is a 0-filled Buffer so just set next offset\n          o.l += file.size + 63 & -64;\n        } else {\n          for (j = 0; j < file.size; ++j) o.write_shift(1, file.content[j]);\n          for (; j & 0x3F; ++j) o.write_shift(1, 0);\n        }\n      }\n    }\n    if (has_buf) {\n      o.l = o.length;\n    } else {\n      // When using Buffer, already 0-filled\n      while (o.l < o.length) o.write_shift(1, 0);\n    }\n    return o;\n  }\n  /* [MS-CFB] 2.6.4 (Unicode 3.0.1 case conversion) */\n  function find(cfb, path) {\n    var UCFullPaths = cfb.FullPaths.map(function (x) {\n      return x.toUpperCase();\n    });\n    var UCPaths = UCFullPaths.map(function (x) {\n      var y = x.split(\"/\");\n      return y[y.length - (x.slice(-1) == \"/\" ? 2 : 1)];\n    });\n    var k = false;\n    if (path.charCodeAt(0) === 47 /* \"/\" */) {\n      k = true;\n      path = UCFullPaths[0].slice(0, -1) + path;\n    } else k = path.indexOf(\"/\") !== -1;\n    var UCPath = path.toUpperCase();\n    var w = k === true ? UCFullPaths.indexOf(UCPath) : UCPaths.indexOf(UCPath);\n    if (w !== -1) return cfb.FileIndex[w];\n    var m = !UCPath.match(chr1);\n    UCPath = UCPath.replace(chr0, '');\n    if (m) UCPath = UCPath.replace(chr1, '!');\n    for (w = 0; w < UCFullPaths.length; ++w) {\n      if ((m ? UCFullPaths[w].replace(chr1, '!') : UCFullPaths[w]).replace(chr0, '') == UCPath) return cfb.FileIndex[w];\n      if ((m ? UCPaths[w].replace(chr1, '!') : UCPaths[w]).replace(chr0, '') == UCPath) return cfb.FileIndex[w];\n    }\n    return null;\n  }\n  /** CFB Constants */\n  var MSSZ = 64; /* Mini Sector Size = 1<<6 */\n  //var MSCSZ = 4096; /* Mini Stream Cutoff Size */\n  /* 2.1 Compound File Sector Numbers and Types */\n  var ENDOFCHAIN = -2;\n  /* 2.2 Compound File Header */\n  var HEADER_SIGNATURE = 'd0cf11e0a1b11ae1';\n  var HEADER_SIG = [0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1];\n  var HEADER_CLSID = '00000000000000000000000000000000';\n  var consts = {\n    /* 2.1 Compund File Sector Numbers and Types */\n    MAXREGSECT: -6,\n    DIFSECT: -4,\n    FATSECT: -3,\n    ENDOFCHAIN: ENDOFCHAIN,\n    FREESECT: -1,\n    /* 2.2 Compound File Header */\n    HEADER_SIGNATURE: HEADER_SIGNATURE,\n    HEADER_MINOR_VERSION: '3e00',\n    MAXREGSID: -6,\n    NOSTREAM: -1,\n    HEADER_CLSID: HEADER_CLSID,\n    /* 2.6.1 Compound File Directory Entry */\n    EntryTypes: ['unknown', 'storage', 'stream', 'lockbytes', 'property', 'root']\n  };\n  function write_file(cfb, filename, options) {\n    get_fs();\n    var o = _write(cfb, options);\n    fs.writeFileSync(filename, o);\n  }\n  function a2s(o) {\n    var out = new Array(o.length);\n    for (var i = 0; i < o.length; ++i) out[i] = String.fromCharCode(o[i]);\n    return out.join(\"\");\n  }\n  function write(cfb, options) {\n    var o = _write(cfb, options);\n    switch (options && options.type || \"buffer\") {\n      case \"file\":\n        get_fs();\n        fs.writeFileSync(options.filename, o);\n        return o;\n      case \"binary\":\n        return typeof o == \"string\" ? o : a2s(o);\n      case \"base64\":\n        return Base64_encode(typeof o == \"string\" ? o : a2s(o));\n      case \"buffer\":\n        if (has_buf) return Buffer.isBuffer(o) ? o : Buffer_from(o);\n      /* falls through */\n      case \"array\":\n        return typeof o == \"string\" ? s2a(o) : o;\n    }\n    return o;\n  }\n  /* node < 8.1 zlib does not expose bytesRead, so default to pure JS */\n  var _zlib;\n  function use_zlib(zlib) {\n    try {\n      var InflateRaw = zlib.InflateRaw;\n      var InflRaw = new InflateRaw();\n      InflRaw._processChunk(new Uint8Array([3, 0]), InflRaw._finishFlushFlag);\n      if (InflRaw.bytesRead) _zlib = zlib;else throw new Error(\"zlib does not expose bytesRead\");\n    } catch (e) {\n      console.error(\"cannot use native zlib: \" + (e.message || e));\n    }\n  }\n  function _inflateRawSync(payload, usz) {\n    if (!_zlib) return _inflate(payload, usz);\n    var InflateRaw = _zlib.InflateRaw;\n    var InflRaw = new InflateRaw();\n    var out = InflRaw._processChunk(payload.slice(payload.l), InflRaw._finishFlushFlag);\n    payload.l += InflRaw.bytesRead;\n    return out;\n  }\n  function _deflateRawSync(payload) {\n    return _zlib ? _zlib.deflateRawSync(payload) : _deflate(payload);\n  }\n  var CLEN_ORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\n  /*  LEN_ID = [ 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285 ]; */\n  var LEN_LN = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258];\n\n  /*  DST_ID = [  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13,  14,  15,  16,  17,  18,  19,   20,   21,   22,   23,   24,   25,   26,    27,    28,    29 ]; */\n  var DST_LN = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];\n  function bit_swap_8(n) {\n    var t = (n << 1 | n << 11) & 0x22110 | (n << 5 | n << 15) & 0x88440;\n    return (t >> 16 | t >> 8 | t) & 0xFF;\n  }\n  var use_typed_arrays = typeof Uint8Array !== 'undefined';\n  var bitswap8 = use_typed_arrays ? new Uint8Array(1 << 8) : [];\n  for (var q = 0; q < 1 << 8; ++q) bitswap8[q] = bit_swap_8(q);\n  function bit_swap_n(n, b) {\n    var rev = bitswap8[n & 0xFF];\n    if (b <= 8) return rev >>> 8 - b;\n    rev = rev << 8 | bitswap8[n >> 8 & 0xFF];\n    if (b <= 16) return rev >>> 16 - b;\n    rev = rev << 8 | bitswap8[n >> 16 & 0xFF];\n    return rev >>> 24 - b;\n  }\n\n  /* helpers for unaligned bit reads */\n  function read_bits_2(buf, bl) {\n    var w = bl & 7,\n      h = bl >>> 3;\n    return (buf[h] | (w <= 6 ? 0 : buf[h + 1] << 8)) >>> w & 0x03;\n  }\n  function read_bits_3(buf, bl) {\n    var w = bl & 7,\n      h = bl >>> 3;\n    return (buf[h] | (w <= 5 ? 0 : buf[h + 1] << 8)) >>> w & 0x07;\n  }\n  function read_bits_4(buf, bl) {\n    var w = bl & 7,\n      h = bl >>> 3;\n    return (buf[h] | (w <= 4 ? 0 : buf[h + 1] << 8)) >>> w & 0x0F;\n  }\n  function read_bits_5(buf, bl) {\n    var w = bl & 7,\n      h = bl >>> 3;\n    return (buf[h] | (w <= 3 ? 0 : buf[h + 1] << 8)) >>> w & 0x1F;\n  }\n  function read_bits_7(buf, bl) {\n    var w = bl & 7,\n      h = bl >>> 3;\n    return (buf[h] | (w <= 1 ? 0 : buf[h + 1] << 8)) >>> w & 0x7F;\n  }\n\n  /* works up to n = 3 * 8 + 1 = 25 */\n  function read_bits_n(buf, bl, n) {\n    var w = bl & 7,\n      h = bl >>> 3,\n      f = (1 << n) - 1;\n    var v = buf[h] >>> w;\n    if (n < 8 - w) return v & f;\n    v |= buf[h + 1] << 8 - w;\n    if (n < 16 - w) return v & f;\n    v |= buf[h + 2] << 16 - w;\n    if (n < 24 - w) return v & f;\n    v |= buf[h + 3] << 24 - w;\n    return v & f;\n  }\n\n  /* helpers for unaligned bit writes */\n  function write_bits_3(buf, bl, v) {\n    var w = bl & 7,\n      h = bl >>> 3;\n    if (w <= 5) buf[h] |= (v & 7) << w;else {\n      buf[h] |= v << w & 0xFF;\n      buf[h + 1] = (v & 7) >> 8 - w;\n    }\n    return bl + 3;\n  }\n  function write_bits_1(buf, bl, v) {\n    var w = bl & 7,\n      h = bl >>> 3;\n    v = (v & 1) << w;\n    buf[h] |= v;\n    return bl + 1;\n  }\n  function write_bits_8(buf, bl, v) {\n    var w = bl & 7,\n      h = bl >>> 3;\n    v <<= w;\n    buf[h] |= v & 0xFF;\n    v >>>= 8;\n    buf[h + 1] = v;\n    return bl + 8;\n  }\n  function write_bits_16(buf, bl, v) {\n    var w = bl & 7,\n      h = bl >>> 3;\n    v <<= w;\n    buf[h] |= v & 0xFF;\n    v >>>= 8;\n    buf[h + 1] = v & 0xFF;\n    buf[h + 2] = v >>> 8;\n    return bl + 16;\n  }\n\n  /* until ArrayBuffer#realloc is a thing, fake a realloc */\n  function realloc(b, sz) {\n    var L = b.length,\n      M = 2 * L > sz ? 2 * L : sz + 5,\n      i = 0;\n    if (L >= sz) return b;\n    if (has_buf) {\n      var o = new_unsafe_buf(M);\n      // $FlowIgnore\n      if (b.copy) b.copy(o);else for (; i < b.length; ++i) o[i] = b[i];\n      return o;\n    } else if (use_typed_arrays) {\n      var a = new Uint8Array(M);\n      if (a.set) a.set(b);else for (; i < L; ++i) a[i] = b[i];\n      return a;\n    }\n    b.length = M;\n    return b;\n  }\n\n  /* zero-filled arrays for older browsers */\n  function zero_fill_array(n) {\n    var o = new Array(n);\n    for (var i = 0; i < n; ++i) o[i] = 0;\n    return o;\n  }\n\n  /* build tree (used for literals and lengths) */\n  function build_tree(clens, cmap, MAX) {\n    var maxlen = 1,\n      w = 0,\n      i = 0,\n      j = 0,\n      ccode = 0,\n      L = clens.length;\n    var bl_count = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);\n    for (i = 0; i < 32; ++i) bl_count[i] = 0;\n    for (i = L; i < MAX; ++i) clens[i] = 0;\n    L = clens.length;\n    var ctree = use_typed_arrays ? new Uint16Array(L) : zero_fill_array(L); // []\n\n    /* build code tree */\n    for (i = 0; i < L; ++i) {\n      bl_count[w = clens[i]]++;\n      if (maxlen < w) maxlen = w;\n      ctree[i] = 0;\n    }\n    bl_count[0] = 0;\n    for (i = 1; i <= maxlen; ++i) bl_count[i + 16] = ccode = ccode + bl_count[i - 1] << 1;\n    for (i = 0; i < L; ++i) {\n      ccode = clens[i];\n      if (ccode != 0) ctree[i] = bl_count[ccode + 16]++;\n    }\n\n    /* cmap[maxlen + 4 bits] = (off&15) + (lit<<4) reverse mapping */\n    var cleni = 0;\n    for (i = 0; i < L; ++i) {\n      cleni = clens[i];\n      if (cleni != 0) {\n        ccode = bit_swap_n(ctree[i], maxlen) >> maxlen - cleni;\n        for (j = (1 << maxlen + 4 - cleni) - 1; j >= 0; --j) cmap[ccode | j << cleni] = cleni & 15 | i << 4;\n      }\n    }\n    return maxlen;\n  }\n\n  /* Fixed Huffman */\n  var fix_lmap = use_typed_arrays ? new Uint16Array(512) : zero_fill_array(512);\n  var fix_dmap = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);\n  if (!use_typed_arrays) {\n    for (var i = 0; i < 512; ++i) fix_lmap[i] = 0;\n    for (i = 0; i < 32; ++i) fix_dmap[i] = 0;\n  }\n  (function () {\n    var dlens = [];\n    var i = 0;\n    for (; i < 32; i++) dlens.push(5);\n    build_tree(dlens, fix_dmap, 32);\n    var clens = [];\n    i = 0;\n    for (; i <= 143; i++) clens.push(8);\n    for (; i <= 255; i++) clens.push(9);\n    for (; i <= 279; i++) clens.push(7);\n    for (; i <= 287; i++) clens.push(8);\n    build_tree(clens, fix_lmap, 288);\n  })();\n  var _deflateRaw = function _deflateRawIIFE() {\n    var DST_LN_RE = use_typed_arrays ? new Uint8Array(0x8000) : [];\n    var j = 0,\n      k = 0;\n    for (; j < DST_LN.length - 1; ++j) {\n      for (; k < DST_LN[j + 1]; ++k) DST_LN_RE[k] = j;\n    }\n    for (; k < 32768; ++k) DST_LN_RE[k] = 29;\n    var LEN_LN_RE = use_typed_arrays ? new Uint8Array(0x103) : [];\n    for (j = 0, k = 0; j < LEN_LN.length - 1; ++j) {\n      for (; k < LEN_LN[j + 1]; ++k) LEN_LN_RE[k] = j;\n    }\n    function write_stored(data, out) {\n      var boff = 0;\n      while (boff < data.length) {\n        var L = Math.min(0xFFFF, data.length - boff);\n        var h = boff + L == data.length;\n        out.write_shift(1, +h);\n        out.write_shift(2, L);\n        out.write_shift(2, ~L & 0xFFFF);\n        while (L-- > 0) out[out.l++] = data[boff++];\n      }\n      return out.l;\n    }\n\n    /* Fixed Huffman */\n    function write_huff_fixed(data, out) {\n      var bl = 0;\n      var boff = 0;\n      var addrs = use_typed_arrays ? new Uint16Array(0x8000) : [];\n      while (boff < data.length) {\n        var L = /* data.length - boff; */Math.min(0xFFFF, data.length - boff);\n\n        /* write a stored block for short data */\n        if (L < 10) {\n          bl = write_bits_3(out, bl, +!!(boff + L == data.length)); // jshint ignore:line\n          if (bl & 7) bl += 8 - (bl & 7);\n          out.l = bl / 8 | 0;\n          out.write_shift(2, L);\n          out.write_shift(2, ~L & 0xFFFF);\n          while (L-- > 0) out[out.l++] = data[boff++];\n          bl = out.l * 8;\n          continue;\n        }\n        bl = write_bits_3(out, bl, +!!(boff + L == data.length) + 2); // jshint ignore:line\n        var hash = 0;\n        while (L-- > 0) {\n          var d = data[boff];\n          hash = (hash << 5 ^ d) & 0x7FFF;\n          var match = -1,\n            mlen = 0;\n          if (match = addrs[hash]) {\n            match |= boff & ~0x7FFF;\n            if (match > boff) match -= 0x8000;\n            if (match < boff) while (data[match + mlen] == data[boff + mlen] && mlen < 250) ++mlen;\n          }\n          if (mlen > 2) {\n            /* Copy Token  */\n            d = LEN_LN_RE[mlen];\n            if (d <= 22) bl = write_bits_8(out, bl, bitswap8[d + 1] >> 1) - 1;else {\n              write_bits_8(out, bl, 3);\n              bl += 5;\n              write_bits_8(out, bl, bitswap8[d - 23] >> 5);\n              bl += 3;\n            }\n            var len_eb = d < 8 ? 0 : d - 4 >> 2;\n            if (len_eb > 0) {\n              write_bits_16(out, bl, mlen - LEN_LN[d]);\n              bl += len_eb;\n            }\n            d = DST_LN_RE[boff - match];\n            bl = write_bits_8(out, bl, bitswap8[d] >> 3);\n            bl -= 3;\n            var dst_eb = d < 4 ? 0 : d - 2 >> 1;\n            if (dst_eb > 0) {\n              write_bits_16(out, bl, boff - match - DST_LN[d]);\n              bl += dst_eb;\n            }\n            for (var q = 0; q < mlen; ++q) {\n              addrs[hash] = boff & 0x7FFF;\n              hash = (hash << 5 ^ data[boff]) & 0x7FFF;\n              ++boff;\n            }\n            L -= mlen - 1;\n          } else {\n            /* Literal Token */\n            if (d <= 143) d = d + 48;else bl = write_bits_1(out, bl, 1);\n            bl = write_bits_8(out, bl, bitswap8[d]);\n            addrs[hash] = boff & 0x7FFF;\n            ++boff;\n          }\n        }\n        bl = write_bits_8(out, bl, 0) - 1;\n      }\n      out.l = (bl + 7) / 8 | 0;\n      return out.l;\n    }\n    return function _deflateRaw(data, out) {\n      if (data.length < 8) return write_stored(data, out);\n      return write_huff_fixed(data, out);\n    };\n  }();\n  function _deflate(data) {\n    var buf = new_buf(50 + Math.floor(data.length * 1.1));\n    var off = _deflateRaw(data, buf);\n    return buf.slice(0, off);\n  }\n  /* modified inflate function also moves original read head */\n\n  var dyn_lmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);\n  var dyn_dmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);\n  var dyn_cmap = use_typed_arrays ? new Uint16Array(128) : zero_fill_array(128);\n  var dyn_len_1 = 1,\n    dyn_len_2 = 1;\n\n  /* 5.5.3 Expanding Huffman Codes */\n  function dyn(data, boff) {\n    /* nomenclature from RFC1951 refers to bit values; these are offset by the implicit constant */\n    var _HLIT = read_bits_5(data, boff) + 257;\n    boff += 5;\n    var _HDIST = read_bits_5(data, boff) + 1;\n    boff += 5;\n    var _HCLEN = read_bits_4(data, boff) + 4;\n    boff += 4;\n    var w = 0;\n\n    /* grab and store code lengths */\n    var clens = use_typed_arrays ? new Uint8Array(19) : zero_fill_array(19);\n    var ctree = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    var maxlen = 1;\n    var bl_count = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);\n    var next_code = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);\n    var L = clens.length; /* 19 */\n    for (var i = 0; i < _HCLEN; ++i) {\n      clens[CLEN_ORDER[i]] = w = read_bits_3(data, boff);\n      if (maxlen < w) maxlen = w;\n      bl_count[w]++;\n      boff += 3;\n    }\n\n    /* build code tree */\n    var ccode = 0;\n    bl_count[0] = 0;\n    for (i = 1; i <= maxlen; ++i) next_code[i] = ccode = ccode + bl_count[i - 1] << 1;\n    for (i = 0; i < L; ++i) if ((ccode = clens[i]) != 0) ctree[i] = next_code[ccode]++;\n    /* cmap[7 bits from stream] = (off&7) + (lit<<3) */\n    var cleni = 0;\n    for (i = 0; i < L; ++i) {\n      cleni = clens[i];\n      if (cleni != 0) {\n        ccode = bitswap8[ctree[i]] >> 8 - cleni;\n        for (var j = (1 << 7 - cleni) - 1; j >= 0; --j) dyn_cmap[ccode | j << cleni] = cleni & 7 | i << 3;\n      }\n    }\n\n    /* read literal and dist codes at once */\n    var hcodes = [];\n    maxlen = 1;\n    for (; hcodes.length < _HLIT + _HDIST;) {\n      ccode = dyn_cmap[read_bits_7(data, boff)];\n      boff += ccode & 7;\n      switch (ccode >>>= 3) {\n        case 16:\n          w = 3 + read_bits_2(data, boff);\n          boff += 2;\n          ccode = hcodes[hcodes.length - 1];\n          while (w-- > 0) hcodes.push(ccode);\n          break;\n        case 17:\n          w = 3 + read_bits_3(data, boff);\n          boff += 3;\n          while (w-- > 0) hcodes.push(0);\n          break;\n        case 18:\n          w = 11 + read_bits_7(data, boff);\n          boff += 7;\n          while (w-- > 0) hcodes.push(0);\n          break;\n        default:\n          hcodes.push(ccode);\n          if (maxlen < ccode) maxlen = ccode;\n          break;\n      }\n    }\n\n    /* build literal / length trees */\n    var h1 = hcodes.slice(0, _HLIT),\n      h2 = hcodes.slice(_HLIT);\n    for (i = _HLIT; i < 286; ++i) h1[i] = 0;\n    for (i = _HDIST; i < 30; ++i) h2[i] = 0;\n    dyn_len_1 = build_tree(h1, dyn_lmap, 286);\n    dyn_len_2 = build_tree(h2, dyn_dmap, 30);\n    return boff;\n  }\n\n  /* return [ data, bytesRead ] */\n  function inflate(data, usz) {\n    /* shortcircuit for empty buffer [0x03, 0x00] */\n    if (data[0] == 3 && !(data[1] & 0x3)) {\n      return [new_raw_buf(usz), 2];\n    }\n\n    /* bit offset */\n    var boff = 0;\n\n    /* header includes final bit and type bits */\n    var header = 0;\n    var outbuf = new_unsafe_buf(usz ? usz : 1 << 18);\n    var woff = 0;\n    var OL = outbuf.length >>> 0;\n    var max_len_1 = 0,\n      max_len_2 = 0;\n    while ((header & 1) == 0) {\n      header = read_bits_3(data, boff);\n      boff += 3;\n      if (header >>> 1 == 0) {\n        /* Stored block */\n        if (boff & 7) boff += 8 - (boff & 7);\n        /* 2 bytes sz, 2 bytes bit inverse */\n        var sz = data[boff >>> 3] | data[(boff >>> 3) + 1] << 8;\n        boff += 32;\n        /* push sz bytes */\n        if (sz > 0) {\n          if (!usz && OL < woff + sz) {\n            outbuf = realloc(outbuf, woff + sz);\n            OL = outbuf.length;\n          }\n          while (sz-- > 0) {\n            outbuf[woff++] = data[boff >>> 3];\n            boff += 8;\n          }\n        }\n        continue;\n      } else if (header >> 1 == 1) {\n        /* Fixed Huffman */\n        max_len_1 = 9;\n        max_len_2 = 5;\n      } else {\n        /* Dynamic Huffman */\n        boff = dyn(data, boff);\n        max_len_1 = dyn_len_1;\n        max_len_2 = dyn_len_2;\n      }\n      for (;;) {\n        // while(true) is apparently out of vogue in modern JS circles\n        if (!usz && OL < woff + 32767) {\n          outbuf = realloc(outbuf, woff + 32767);\n          OL = outbuf.length;\n        }\n        /* ingest code and move read head */\n        var bits = read_bits_n(data, boff, max_len_1);\n        var code = header >>> 1 == 1 ? fix_lmap[bits] : dyn_lmap[bits];\n        boff += code & 15;\n        code >>>= 4;\n        /* 0-255 are literals, 256 is end of block token, 257+ are copy tokens */\n        if ((code >>> 8 & 0xFF) === 0) outbuf[woff++] = code;else if (code == 256) break;else {\n          code -= 257;\n          var len_eb = code < 8 ? 0 : code - 4 >> 2;\n          if (len_eb > 5) len_eb = 0;\n          var tgt = woff + LEN_LN[code];\n          /* length extra bits */\n          if (len_eb > 0) {\n            tgt += read_bits_n(data, boff, len_eb);\n            boff += len_eb;\n          }\n\n          /* dist code */\n          bits = read_bits_n(data, boff, max_len_2);\n          code = header >>> 1 == 1 ? fix_dmap[bits] : dyn_dmap[bits];\n          boff += code & 15;\n          code >>>= 4;\n          var dst_eb = code < 4 ? 0 : code - 2 >> 1;\n          var dst = DST_LN[code];\n          /* dist extra bits */\n          if (dst_eb > 0) {\n            dst += read_bits_n(data, boff, dst_eb);\n            boff += dst_eb;\n          }\n\n          /* in the common case, manual byte copy is faster than TA set / Buffer copy */\n          if (!usz && OL < tgt) {\n            outbuf = realloc(outbuf, tgt + 100);\n            OL = outbuf.length;\n          }\n          while (woff < tgt) {\n            outbuf[woff] = outbuf[woff - dst];\n            ++woff;\n          }\n        }\n      }\n    }\n    if (usz) return [outbuf, boff + 7 >>> 3];\n    return [outbuf.slice(0, woff), boff + 7 >>> 3];\n  }\n  function _inflate(payload, usz) {\n    var data = payload.slice(payload.l || 0);\n    var out = inflate(data, usz);\n    payload.l += out[1];\n    return out[0];\n  }\n  function warn_or_throw(wrn, msg) {\n    if (wrn) {\n      if (typeof console !== 'undefined') console.error(msg);\n    } else throw new Error(msg);\n  }\n  function parse_zip(file, options) {\n    var blob = file;\n    prep_blob(blob, 0);\n    var FileIndex = [],\n      FullPaths = [];\n    var o = {\n      FileIndex: FileIndex,\n      FullPaths: FullPaths\n    };\n    init_cfb(o, {\n      root: options.root\n    });\n\n    /* find end of central directory, start just after signature */\n    var i = blob.length - 4;\n    while ((blob[i] != 0x50 || blob[i + 1] != 0x4b || blob[i + 2] != 0x05 || blob[i + 3] != 0x06) && i >= 0) --i;\n    blob.l = i + 4;\n\n    /* parse end of central directory */\n    blob.l += 4;\n    var fcnt = blob.read_shift(2);\n    blob.l += 6;\n    var start_cd = blob.read_shift(4);\n\n    /* parse central directory */\n    blob.l = start_cd;\n    for (i = 0; i < fcnt; ++i) {\n      /* trust local file header instead of CD entry */\n      blob.l += 20;\n      var csz = blob.read_shift(4);\n      var usz = blob.read_shift(4);\n      var namelen = blob.read_shift(2);\n      var efsz = blob.read_shift(2);\n      var fcsz = blob.read_shift(2);\n      blob.l += 8;\n      var offset = blob.read_shift(4);\n      var EF = parse_extra_field(blob.slice(blob.l + namelen, blob.l + namelen + efsz));\n      blob.l += namelen + efsz + fcsz;\n      var L = blob.l;\n      blob.l = offset + 4;\n      parse_local_file(blob, csz, usz, o, EF);\n      blob.l = L;\n    }\n    return o;\n  }\n\n  /* head starts just after local file header signature */\n  function parse_local_file(blob, csz, usz, o, EF) {\n    /* [local file header] */\n    blob.l += 2;\n    var flags = blob.read_shift(2);\n    var meth = blob.read_shift(2);\n    var date = parse_dos_date(blob);\n    if (flags & 0x2041) throw new Error(\"Unsupported ZIP encryption\");\n    var crc32 = blob.read_shift(4);\n    var _csz = blob.read_shift(4);\n    var _usz = blob.read_shift(4);\n    var namelen = blob.read_shift(2);\n    var efsz = blob.read_shift(2);\n\n    // TODO: flags & (1<<11) // UTF8\n    var name = \"\";\n    for (var i = 0; i < namelen; ++i) name += String.fromCharCode(blob[blob.l++]);\n    if (efsz) {\n      var ef = parse_extra_field(blob.slice(blob.l, blob.l + efsz));\n      if ((ef[0x5455] || {}).mt) date = ef[0x5455].mt;\n      if (((EF || {})[0x5455] || {}).mt) date = EF[0x5455].mt;\n    }\n    blob.l += efsz;\n\n    /* [encryption header] */\n\n    /* [file data] */\n    var data = blob.slice(blob.l, blob.l + _csz);\n    switch (meth) {\n      case 8:\n        data = _inflateRawSync(blob, _usz);\n        break;\n      case 0:\n        break;\n      // TODO: scan for magic number\n      default:\n        throw new Error(\"Unsupported ZIP Compression method \" + meth);\n    }\n\n    /* [data descriptor] */\n    var wrn = false;\n    if (flags & 8) {\n      crc32 = blob.read_shift(4);\n      if (crc32 == 0x08074b50) {\n        crc32 = blob.read_shift(4);\n        wrn = true;\n      }\n      _csz = blob.read_shift(4);\n      _usz = blob.read_shift(4);\n    }\n    if (_csz != csz) warn_or_throw(wrn, \"Bad compressed size: \" + csz + \" != \" + _csz);\n    if (_usz != usz) warn_or_throw(wrn, \"Bad uncompressed size: \" + usz + \" != \" + _usz);\n    var _crc32 = CRC32.buf(data, 0);\n    if (crc32 >> 0 != _crc32 >> 0) warn_or_throw(wrn, \"Bad CRC32 checksum: \" + crc32 + \" != \" + _crc32);\n    cfb_add(o, name, data, {\n      unsafe: true,\n      mt: date\n    });\n  }\n  function write_zip(cfb, options) {\n    var _opts = options || {};\n    var out = [],\n      cdirs = [];\n    var o = new_buf(1);\n    var method = _opts.compression ? 8 : 0,\n      flags = 0;\n    var desc = false;\n    if (desc) flags |= 8;\n    var i = 0,\n      j = 0;\n    var start_cd = 0,\n      fcnt = 0;\n    var root = cfb.FullPaths[0],\n      fp = root,\n      fi = cfb.FileIndex[0];\n    var crcs = [];\n    var sz_cd = 0;\n    for (i = 1; i < cfb.FullPaths.length; ++i) {\n      fp = cfb.FullPaths[i].slice(root.length);\n      fi = cfb.FileIndex[i];\n      if (!fi.size || !fi.content || fp == \"\\x01Sh33tJ5\") continue;\n      var start = start_cd;\n\n      /* TODO: CP437 filename */\n      var namebuf = new_buf(fp.length);\n      for (j = 0; j < fp.length; ++j) namebuf.write_shift(1, fp.charCodeAt(j) & 0x7F);\n      namebuf = namebuf.slice(0, namebuf.l);\n      crcs[fcnt] = CRC32.buf(fi.content, 0);\n      var outbuf = fi.content;\n      if (method == 8) outbuf = _deflateRawSync(outbuf);\n\n      /* local file header */\n      o = new_buf(30);\n      o.write_shift(4, 0x04034b50);\n      o.write_shift(2, 20);\n      o.write_shift(2, flags);\n      o.write_shift(2, method);\n      /* TODO: last mod file time/date */\n      if (fi.mt) write_dos_date(o, fi.mt);else o.write_shift(4, 0);\n      o.write_shift(-4, flags & 8 ? 0 : crcs[fcnt]);\n      o.write_shift(4, flags & 8 ? 0 : outbuf.length);\n      o.write_shift(4, flags & 8 ? 0 : fi.content.length);\n      o.write_shift(2, namebuf.length);\n      o.write_shift(2, 0);\n      start_cd += o.length;\n      out.push(o);\n      start_cd += namebuf.length;\n      out.push(namebuf);\n\n      /* TODO: extra fields? */\n\n      /* TODO: encryption header ? */\n\n      start_cd += outbuf.length;\n      out.push(outbuf);\n\n      /* data descriptor */\n      if (flags & 8) {\n        o = new_buf(12);\n        o.write_shift(-4, crcs[fcnt]);\n        o.write_shift(4, outbuf.length);\n        o.write_shift(4, fi.content.length);\n        start_cd += o.l;\n        out.push(o);\n      }\n\n      /* central directory */\n      o = new_buf(46);\n      o.write_shift(4, 0x02014b50);\n      o.write_shift(2, 0);\n      o.write_shift(2, 20);\n      o.write_shift(2, flags);\n      o.write_shift(2, method);\n      o.write_shift(4, 0); /* TODO: last mod file time/date */\n      o.write_shift(-4, crcs[fcnt]);\n      o.write_shift(4, outbuf.length);\n      o.write_shift(4, fi.content.length);\n      o.write_shift(2, namebuf.length);\n      o.write_shift(2, 0);\n      o.write_shift(2, 0);\n      o.write_shift(2, 0);\n      o.write_shift(2, 0);\n      o.write_shift(4, 0);\n      o.write_shift(4, start);\n      sz_cd += o.l;\n      cdirs.push(o);\n      sz_cd += namebuf.length;\n      cdirs.push(namebuf);\n      ++fcnt;\n    }\n\n    /* end of central directory */\n    o = new_buf(22);\n    o.write_shift(4, 0x06054b50);\n    o.write_shift(2, 0);\n    o.write_shift(2, 0);\n    o.write_shift(2, fcnt);\n    o.write_shift(2, fcnt);\n    o.write_shift(4, sz_cd);\n    o.write_shift(4, start_cd);\n    o.write_shift(2, 0);\n    return bconcat([bconcat(out), bconcat(cdirs), o]);\n  }\n  var ContentTypeMap = {\n    \"htm\": \"text/html\",\n    \"xml\": \"text/xml\",\n    \"gif\": \"image/gif\",\n    \"jpg\": \"image/jpeg\",\n    \"png\": \"image/png\",\n    \"mso\": \"application/x-mso\",\n    \"thmx\": \"application/vnd.ms-officetheme\",\n    \"sh33tj5\": \"application/octet-stream\"\n  };\n  function get_content_type(fi, fp) {\n    if (fi.ctype) return fi.ctype;\n    var ext = fi.name || \"\",\n      m = ext.match(/\\.([^\\.]+)$/);\n    if (m && ContentTypeMap[m[1]]) return ContentTypeMap[m[1]];\n    if (fp) {\n      m = (ext = fp).match(/[\\.\\\\]([^\\.\\\\])+$/);\n      if (m && ContentTypeMap[m[1]]) return ContentTypeMap[m[1]];\n    }\n    return \"application/octet-stream\";\n  }\n\n  /* 76 character chunks TODO: intertwine encoding */\n  function write_base64_76(bstr) {\n    var data = Base64_encode(bstr);\n    var o = [];\n    for (var i = 0; i < data.length; i += 76) o.push(data.slice(i, i + 76));\n    return o.join(\"\\r\\n\") + \"\\r\\n\";\n  }\n\n  /*\n  Rules for QP:\n  \t- escape =## applies for all non-display characters and literal \"=\"\n  \t- space or tab at end of line must be encoded\n  \t- \\r\\n newlines can be preserved, but bare \\r and \\n must be escaped\n  \t- lines must not exceed 76 characters, use soft breaks =\\r\\n\n  \n  TODO: Some files from word appear to write line extensions with bare equals:\n  \n  ```\n  <table class=3DMsoTableGrid border=3D1 cellspacing=3D0 cellpadding=3D0 width=\n  =\"70%\"\n  ```\n  */\n  function write_quoted_printable(text) {\n    var encoded = text.replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7E-\\xFF=]/g, function (c) {\n      var w = c.charCodeAt(0).toString(16).toUpperCase();\n      return \"=\" + (w.length == 1 ? \"0\" + w : w);\n    });\n    encoded = encoded.replace(/ $/mg, \"=20\").replace(/\\t$/mg, \"=09\");\n    if (encoded.charAt(0) == \"\\n\") encoded = \"=0D\" + encoded.slice(1);\n    encoded = encoded.replace(/\\r(?!\\n)/mg, \"=0D\").replace(/\\n\\n/mg, \"\\n=0A\").replace(/([^\\r\\n])\\n/mg, \"$1=0A\");\n    var o = [],\n      split = encoded.split(\"\\r\\n\");\n    for (var si = 0; si < split.length; ++si) {\n      var str = split[si];\n      if (str.length == 0) {\n        o.push(\"\");\n        continue;\n      }\n      for (var i = 0; i < str.length;) {\n        var end = 76;\n        var tmp = str.slice(i, i + end);\n        if (tmp.charAt(end - 1) == \"=\") end--;else if (tmp.charAt(end - 2) == \"=\") end -= 2;else if (tmp.charAt(end - 3) == \"=\") end -= 3;\n        tmp = str.slice(i, i + end);\n        i += end;\n        if (i < str.length) tmp += \"=\";\n        o.push(tmp);\n      }\n    }\n    return o.join(\"\\r\\n\");\n  }\n  function parse_quoted_printable(data) {\n    var o = [];\n\n    /* unify long lines */\n    for (var di = 0; di < data.length; ++di) {\n      var line = data[di];\n      while (di <= data.length && line.charAt(line.length - 1) == \"=\") line = line.slice(0, line.length - 1) + data[++di];\n      o.push(line);\n    }\n\n    /* decode */\n    for (var oi = 0; oi < o.length; ++oi) o[oi] = o[oi].replace(/[=][0-9A-Fa-f]{2}/g, function ($$) {\n      return String.fromCharCode(parseInt($$.slice(1), 16));\n    });\n    return s2a(o.join(\"\\r\\n\"));\n  }\n  function parse_mime(cfb, data, root) {\n    var fname = \"\",\n      cte = \"\",\n      ctype = \"\",\n      fdata;\n    var di = 0;\n    for (; di < 10; ++di) {\n      var line = data[di];\n      if (!line || line.match(/^\\s*$/)) break;\n      var m = line.match(/^(.*?):\\s*([^\\s].*)$/);\n      if (m) switch (m[1].toLowerCase()) {\n        case \"content-location\":\n          fname = m[2].trim();\n          break;\n        case \"content-type\":\n          ctype = m[2].trim();\n          break;\n        case \"content-transfer-encoding\":\n          cte = m[2].trim();\n          break;\n      }\n    }\n    ++di;\n    switch (cte.toLowerCase()) {\n      case 'base64':\n        fdata = s2a(Base64_decode(data.slice(di).join(\"\")));\n        break;\n      case 'quoted-printable':\n        fdata = parse_quoted_printable(data.slice(di));\n        break;\n      default:\n        throw new Error(\"Unsupported Content-Transfer-Encoding \" + cte);\n    }\n    var file = cfb_add(cfb, fname.slice(root.length), fdata, {\n      unsafe: true\n    });\n    if (ctype) file.ctype = ctype;\n  }\n  function parse_mad(file, options) {\n    if (a2s(file.slice(0, 13)).toLowerCase() != \"mime-version:\") throw new Error(\"Unsupported MAD header\");\n    var root = options && options.root || \"\";\n    // $FlowIgnore\n    var data = (has_buf && Buffer.isBuffer(file) ? file.toString(\"binary\") : a2s(file)).split(\"\\r\\n\");\n    var di = 0,\n      row = \"\";\n\n    /* if root is not specified, scan for the common prefix */\n    for (di = 0; di < data.length; ++di) {\n      row = data[di];\n      if (!/^Content-Location:/i.test(row)) continue;\n      row = row.slice(row.indexOf(\"file\"));\n      if (!root) root = row.slice(0, row.lastIndexOf(\"/\") + 1);\n      if (row.slice(0, root.length) == root) continue;\n      while (root.length > 0) {\n        root = root.slice(0, root.length - 1);\n        root = root.slice(0, root.lastIndexOf(\"/\") + 1);\n        if (row.slice(0, root.length) == root) break;\n      }\n    }\n    var mboundary = (data[1] || \"\").match(/boundary=\"(.*?)\"/);\n    if (!mboundary) throw new Error(\"MAD cannot find boundary\");\n    var boundary = \"--\" + (mboundary[1] || \"\");\n    var FileIndex = [],\n      FullPaths = [];\n    var o = {\n      FileIndex: FileIndex,\n      FullPaths: FullPaths\n    };\n    init_cfb(o);\n    var start_di,\n      fcnt = 0;\n    for (di = 0; di < data.length; ++di) {\n      var line = data[di];\n      if (line !== boundary && line !== boundary + \"--\") continue;\n      if (fcnt++) parse_mime(o, data.slice(start_di, di), root);\n      start_di = di;\n    }\n    return o;\n  }\n  function write_mad(cfb, options) {\n    var opts = options || {};\n    var boundary = opts.boundary || \"SheetJS\";\n    boundary = '------=' + boundary;\n    var out = ['MIME-Version: 1.0', 'Content-Type: multipart/related; boundary=\"' + boundary.slice(2) + '\"', '', '', ''];\n    var root = cfb.FullPaths[0],\n      fp = root,\n      fi = cfb.FileIndex[0];\n    for (var i = 1; i < cfb.FullPaths.length; ++i) {\n      fp = cfb.FullPaths[i].slice(root.length);\n      fi = cfb.FileIndex[i];\n      if (!fi.size || !fi.content || fp == \"\\x01Sh33tJ5\") continue;\n\n      /* Normalize filename */\n      fp = fp.replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7E-\\xFF]/g, function (c) {\n        return \"_x\" + c.charCodeAt(0).toString(16) + \"_\";\n      }).replace(/[\\u0080-\\uFFFF]/g, function (u) {\n        return \"_u\" + u.charCodeAt(0).toString(16) + \"_\";\n      });\n\n      /* Extract content as binary string */\n      var ca = fi.content;\n      // $FlowIgnore\n      var cstr = has_buf && Buffer.isBuffer(ca) ? ca.toString(\"binary\") : a2s(ca);\n\n      /* 4/5 of first 1024 chars ascii -> quoted printable, else base64 */\n      var dispcnt = 0,\n        L = Math.min(1024, cstr.length),\n        cc = 0;\n      for (var csl = 0; csl <= L; ++csl) if ((cc = cstr.charCodeAt(csl)) >= 0x20 && cc < 0x80) ++dispcnt;\n      var qp = dispcnt >= L * 4 / 5;\n      out.push(boundary);\n      out.push('Content-Location: ' + (opts.root || 'file:///C:/SheetJS/') + fp);\n      out.push('Content-Transfer-Encoding: ' + (qp ? 'quoted-printable' : 'base64'));\n      out.push('Content-Type: ' + get_content_type(fi, fp));\n      out.push('');\n      out.push(qp ? write_quoted_printable(cstr) : write_base64_76(cstr));\n    }\n    out.push(boundary + '--\\r\\n');\n    return out.join(\"\\r\\n\");\n  }\n  function cfb_new(opts) {\n    var o = {};\n    init_cfb(o, opts);\n    return o;\n  }\n  function cfb_add(cfb, name, content, opts) {\n    var unsafe = opts && opts.unsafe;\n    if (!unsafe) init_cfb(cfb);\n    var file = !unsafe && CFB.find(cfb, name);\n    if (!file) {\n      var fpath = cfb.FullPaths[0];\n      if (name.slice(0, fpath.length) == fpath) fpath = name;else {\n        if (fpath.slice(-1) != \"/\") fpath += \"/\";\n        fpath = (fpath + name).replace(\"//\", \"/\");\n      }\n      file = {\n        name: filename(name),\n        type: 2\n      };\n      cfb.FileIndex.push(file);\n      cfb.FullPaths.push(fpath);\n      if (!unsafe) CFB.utils.cfb_gc(cfb);\n    }\n    file.content = content;\n    file.size = content ? content.length : 0;\n    if (opts) {\n      if (opts.CLSID) file.clsid = opts.CLSID;\n      if (opts.mt) file.mt = opts.mt;\n      if (opts.ct) file.ct = opts.ct;\n    }\n    return file;\n  }\n  function cfb_del(cfb, name) {\n    init_cfb(cfb);\n    var file = CFB.find(cfb, name);\n    if (file) for (var j = 0; j < cfb.FileIndex.length; ++j) if (cfb.FileIndex[j] == file) {\n      cfb.FileIndex.splice(j, 1);\n      cfb.FullPaths.splice(j, 1);\n      return true;\n    }\n    return false;\n  }\n  function cfb_mov(cfb, old_name, new_name) {\n    init_cfb(cfb);\n    var file = CFB.find(cfb, old_name);\n    if (file) for (var j = 0; j < cfb.FileIndex.length; ++j) if (cfb.FileIndex[j] == file) {\n      cfb.FileIndex[j].name = filename(new_name);\n      cfb.FullPaths[j] = new_name;\n      return true;\n    }\n    return false;\n  }\n  function cfb_gc(cfb) {\n    rebuild_cfb(cfb, true);\n  }\n  exports.find = find;\n  exports.read = read;\n  exports.parse = parse;\n  exports.write = write;\n  exports.writeFile = write_file;\n  exports.utils = {\n    cfb_new: cfb_new,\n    cfb_add: cfb_add,\n    cfb_del: cfb_del,\n    cfb_mov: cfb_mov,\n    cfb_gc: cfb_gc,\n    ReadShift: ReadShift,\n    CheckField: CheckField,\n    prep_blob: prep_blob,\n    bconcat: bconcat,\n    use_zlib: use_zlib,\n    _deflateRaw: _deflate,\n    _inflateRaw: _inflate,\n    consts: consts\n  };\n  return exports;\n}();\nif (typeof require !== 'undefined' && typeof module !== 'undefined' && typeof DO_NOT_EXPORT_CFB === 'undefined') {\n  module.exports = CFB;\n}","map":null,"metadata":{},"sourceType":"script"}
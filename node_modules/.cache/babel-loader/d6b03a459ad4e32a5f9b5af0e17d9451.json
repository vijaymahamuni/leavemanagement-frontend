{"ast":null,"code":"\"use strict\";\n\n/* eslint camelcase:off */\nvar _classCallCheck = require(\"C:\\\\Project\\\\Front_end\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Project\\\\Front_end\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar ArgHandler = require(\"./ArgHandler\");\nvar _ = require(\"lodash\");\nvar xmlq = require(\"./xmlq\");\nvar colorIndexes = require(\"./colorIndexes\");\n\n/**\n * A Rich text fragment.\n */\nvar RichTextFragment = /*#__PURE__*/function () {\n  /**\n   * Creates a new instance of RichTextFragment.\n   * @constructor\n   * @param {string|Object} value - Text value or XML node\n   * @param {object|undefined|null} [styles] - Multiple styles.\n   * @param {RichText} richText - The rich text instance where this fragment belongs to.\n   */\n  function RichTextFragment(value, styles, richText) {\n    _classCallCheck(this, RichTextFragment);\n    this._richText = richText;\n    if (value.name === 'r') {\n      this._node = value;\n      this._fontNode = xmlq.findChild(this._node, 'rPr');\n      if (!this._fontNode) {\n        this._fontNode = {\n          name: 'rPr',\n          attributes: {},\n          children: []\n        };\n        this._node.children.unshift(this._fontNode);\n      }\n      this._valueNode = xmlq.findChild(this._node, 't');\n    } else {\n      this._node = {\n        name: 'r',\n        attributes: {},\n        children: [{\n          name: 'rPr',\n          attributes: {},\n          children: []\n        }, {\n          name: 't',\n          attributes: {},\n          children: []\n        }]\n      };\n      this._fontNode = xmlq.findChild(this._node, 'rPr');\n      this._valueNode = xmlq.findChild(this._node, 't');\n      this.value(value);\n      if (styles) {\n        this.style(styles);\n      }\n    }\n  }\n\n  /**\n   * Gets the value of this part of rich text\n   * @return {string} text\n   */ /**\n      * Sets the value of this part of rich text\n      * @param {string} text - the text to set\n      * @return {RichTextFragment} - RichTextFragment\n      */\n  _createClass(RichTextFragment, [{\n    key: \"value\",\n    value: function value() {\n      var _this = this;\n      return new ArgHandler(\"_RichText.value\").case(function () {\n        return _this._valueNode.children[0];\n      }).case('string', function (value) {\n        value = value.replace(/(?:\\r\\n|\\r|\\n)/g, '\\r\\n');\n        var hasLineSeparator = value.indexOf('\\r\\n') !== -1;\n        _this._valueNode.children[0] = value;\n        if (value.charAt(0) === ' ') xmlq.setAttributes(_this._valueNode, {\n          'xml:space': 'preserve'\n        });\n        if (_this._richText) _this._richText.removeUnsupportedNodes();\n        if (hasLineSeparator) {\n          // set wrapText = true if it contains line separator, excel will only display new lines if it sets.\n          if (_this._richText.cell) {\n            _this._richText.cell.style('wrapText', true);\n          }\n          xmlq.setAttributes(_this._valueNode, {\n            'xml:space': 'preserve'\n          });\n        }\n        return _this;\n      }).handle(arguments);\n    }\n    /**\n     * Convert the rich text to an XML object.\n     * @returns {{}} The XML form.\n     * @ignore\n     */\n  }, {\n    key: \"toXml\",\n    value: function toXml() {\n      return this._node;\n    }\n    /**\n     * Gets an individual style.\n     * @param {string} name - The name of the style.\n     * @returns {*} The style.\n     */\n    /**\n    * Gets multiple styles.\n    * @param {Array.<string>} names - The names of the style.\n    * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.\n    */\n    /**\n    * Sets an individual style.\n    * @param {string} name - The name of the style.\n    * @param {*} value - The value to set.\n    * @returns {RichTextFragment} This RichTextFragment.\n    */\n    /**\n    * Sets multiple styles.\n    * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.\n    * @returns {RichTextFragment} This RichTextFragment.\n    */\n  }, {\n    key: \"style\",\n    value: function style() {\n      var _this2 = this;\n      return new ArgHandler(\"_RichText.style\").case('string', function (name) {\n        // Get single value\n        var getterName = \"_get_\".concat(name);\n        if (!_this2[getterName]) throw new Error(\"_RichText.style: '\".concat(name, \"' is not a valid style\"));\n        return _this2[getterName]();\n      }).case('array', function (names) {\n        // Get list of values\n        var values = {};\n        names.forEach(function (name) {\n          values[name] = _this2.style(name);\n        });\n        return values;\n      }).case(['string', '*'], function (name, value) {\n        // Set a single value\n        var setterName = \"_set_\".concat(name);\n        if (!_this2[setterName]) throw new Error(\"_RichText.style: '\".concat(name, \"' is not a valid style\"));\n        return _this2[setterName](value);\n      }).case('object', function (nameValues) {\n        // Object of key value pairs to set\n        for (var name in nameValues) {\n          if (!nameValues.hasOwnProperty(name)) continue;\n          var value = nameValues[name];\n          _this2.style(name, value);\n        }\n        return _this2;\n      }).handle(arguments);\n    }\n  }, {\n    key: \"_getColor\",\n    value: function _getColor(node, name) {\n      var child = xmlq.findChild(node, name);\n      if (!child || !child.attributes) return;\n      var color = {};\n      if (child.attributes.hasOwnProperty('rgb')) color.rgb = child.attributes.rgb;else if (child.attributes.hasOwnProperty('theme')) color.theme = child.attributes.theme;else if (child.attributes.hasOwnProperty('indexed')) color.rgb = colorIndexes[child.attributes.indexed];\n      if (child.attributes.hasOwnProperty('tint')) color.tint = child.attributes.tint;\n      if (_.isEmpty(color)) return;\n      return color;\n    }\n  }, {\n    key: \"_setColor\",\n    value: function _setColor(node, name, color) {\n      if (typeof color === \"string\") color = {\n        rgb: color\n      };else if (typeof color === \"number\") color = {\n        theme: color\n      };\n      xmlq.setChildAttributes(node, name, {\n        rgb: color && color.rgb && color.rgb.toUpperCase(),\n        indexed: null,\n        theme: color && color.theme,\n        tint: color && color.tint\n      });\n      xmlq.removeChildIfEmpty(node, 'color');\n    }\n  }, {\n    key: \"_get_bold\",\n    value: function _get_bold() {\n      return xmlq.hasChild(this._fontNode, 'b');\n    }\n  }, {\n    key: \"_set_bold\",\n    value: function _set_bold(bold) {\n      if (bold) xmlq.appendChildIfNotFound(this._fontNode, \"b\");else xmlq.removeChild(this._fontNode, 'b');\n    }\n  }, {\n    key: \"_get_italic\",\n    value: function _get_italic() {\n      return xmlq.hasChild(this._fontNode, 'i');\n    }\n  }, {\n    key: \"_set_italic\",\n    value: function _set_italic(italic) {\n      if (italic) xmlq.appendChildIfNotFound(this._fontNode, \"i\");else xmlq.removeChild(this._fontNode, 'i');\n    }\n  }, {\n    key: \"_get_underline\",\n    value: function _get_underline() {\n      var uNode = xmlq.findChild(this._fontNode, 'u');\n      return uNode ? uNode.attributes.val || true : false;\n    }\n  }, {\n    key: \"_set_underline\",\n    value: function _set_underline(underline) {\n      if (underline) {\n        var uNode = xmlq.appendChildIfNotFound(this._fontNode, \"u\");\n        var val = typeof underline === 'string' ? underline : null;\n        xmlq.setAttributes(uNode, {\n          val: val\n        });\n      } else {\n        xmlq.removeChild(this._fontNode, 'u');\n      }\n    }\n  }, {\n    key: \"_get_strikethrough\",\n    value: function _get_strikethrough() {\n      return xmlq.hasChild(this._fontNode, 'strike');\n    }\n  }, {\n    key: \"_set_strikethrough\",\n    value: function _set_strikethrough(strikethrough) {\n      if (strikethrough) xmlq.appendChildIfNotFound(this._fontNode, \"strike\");else xmlq.removeChild(this._fontNode, 'strike');\n    }\n  }, {\n    key: \"_getFontVerticalAlignment\",\n    value: function _getFontVerticalAlignment() {\n      return xmlq.getChildAttribute(this._fontNode, 'vertAlign', \"val\");\n    }\n  }, {\n    key: \"_setFontVerticalAlignment\",\n    value: function _setFontVerticalAlignment(alignment) {\n      xmlq.setChildAttributes(this._fontNode, 'vertAlign', {\n        val: alignment\n      });\n      xmlq.removeChildIfEmpty(this._fontNode, 'vertAlign');\n    }\n  }, {\n    key: \"_get_subscript\",\n    value: function _get_subscript() {\n      return this._getFontVerticalAlignment() === \"subscript\";\n    }\n  }, {\n    key: \"_set_subscript\",\n    value: function _set_subscript(subscript) {\n      this._setFontVerticalAlignment(subscript ? \"subscript\" : null);\n    }\n  }, {\n    key: \"_get_superscript\",\n    value: function _get_superscript() {\n      return this._getFontVerticalAlignment() === \"superscript\";\n    }\n  }, {\n    key: \"_set_superscript\",\n    value: function _set_superscript(superscript) {\n      this._setFontVerticalAlignment(superscript ? \"superscript\" : null);\n    }\n  }, {\n    key: \"_get_fontSize\",\n    value: function _get_fontSize() {\n      return xmlq.getChildAttribute(this._fontNode, 'sz', \"val\");\n    }\n  }, {\n    key: \"_set_fontSize\",\n    value: function _set_fontSize(size) {\n      xmlq.setChildAttributes(this._fontNode, 'sz', {\n        val: size\n      });\n      xmlq.removeChildIfEmpty(this._fontNode, 'sz');\n    }\n  }, {\n    key: \"_get_fontFamily\",\n    value: function _get_fontFamily() {\n      return xmlq.getChildAttribute(this._fontNode, 'rFont', \"val\");\n    }\n  }, {\n    key: \"_set_fontFamily\",\n    value: function _set_fontFamily(family) {\n      xmlq.setChildAttributes(this._fontNode, 'rFont', {\n        val: family\n      });\n      xmlq.removeChildIfEmpty(this._fontNode, 'rFont');\n    }\n  }, {\n    key: \"_get_fontGenericFamily\",\n    value: function _get_fontGenericFamily() {\n      return xmlq.getChildAttribute(this._fontNode, 'family', \"val\");\n    }\n    /**\n     * @param {number} genericFamily - 1: Serif, 2: Sans Serif, 3: Monospace,\n     * @private\n     * @return {undefined}\n     */\n  }, {\n    key: \"_set_fontGenericFamily\",\n    value: function _set_fontGenericFamily(genericFamily) {\n      xmlq.setChildAttributes(this._fontNode, 'family', {\n        val: genericFamily\n      });\n      xmlq.removeChildIfEmpty(this._fontNode, 'family');\n    }\n  }, {\n    key: \"_get_fontColor\",\n    value: function _get_fontColor() {\n      return this._getColor(this._fontNode, \"color\");\n    }\n  }, {\n    key: \"_set_fontColor\",\n    value: function _set_fontColor(color) {\n      this._setColor(this._fontNode, \"color\", color);\n    }\n  }, {\n    key: \"_get_fontScheme\",\n    value: function _get_fontScheme() {\n      // can be 'minor', 'major', 'none'\n      return xmlq.getChildAttribute(this._fontNode, 'scheme', \"val\");\n    }\n    /**\n     * @param {string} scheme - 'minor'|'major'|'none'\n     * @private\n     * @return {undefined}\n     */\n  }, {\n    key: \"_set_fontScheme\",\n    value: function _set_fontScheme(scheme) {\n      xmlq.setChildAttributes(this._fontNode, 'scheme', {\n        val: scheme\n      });\n      xmlq.removeChildIfEmpty(this._fontNode, 'scheme');\n    }\n  }]);\n  return RichTextFragment;\n}(); // IE doesn't support function names so explicitly set it.\nif (!RichTextFragment.name) RichTextFragment.name = \"RichTextFragment\";\nmodule.exports = RichTextFragment;","map":null,"metadata":{},"sourceType":"script"}
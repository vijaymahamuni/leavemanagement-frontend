{"ast":null,"code":"\"use strict\";\n\n/**\n * OOXML uses the CFB file format with Agile Encryption. The details of the encryption are here:\n * https://msdn.microsoft.com/en-us/library/dd950165(v=office.12).aspx\n *\n * Helpful guidance also take from this Github project:\n * https://github.com/nolze/ms-offcrypto-tool\n */\nvar _classCallCheck = require(\"C:\\\\Project\\\\Front_end\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Project\\\\Front_end\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _ = require(\"lodash\");\nvar cfb = require(\"cfb\");\nvar crypto = require(\"crypto\");\nvar externals = require(\"./externals\");\nvar XmlParser = require(\"./XmlParser\");\nvar XmlBuilder = require(\"./XmlBuilder\");\nvar xmlq = require(\"./xmlq\");\nvar ENCRYPTION_INFO_PREFIX = Buffer.from([0x04, 0x00, 0x04, 0x00, 0x40, 0x00, 0x00, 0x00]); // First 4 bytes are the version number, second 4 bytes are reserved.\nvar PACKAGE_ENCRYPTION_CHUNK_SIZE = 4096;\nvar PACKAGE_OFFSET = 8; // First 8 bytes are the size of the stream\n\n// Block keys used for encryption\nvar BLOCK_KEYS = {\n  dataIntegrity: {\n    hmacKey: Buffer.from([0x5f, 0xb2, 0xad, 0x01, 0x0c, 0xb9, 0xe1, 0xf6]),\n    hmacValue: Buffer.from([0xa0, 0x67, 0x7f, 0x02, 0xb2, 0x2c, 0x84, 0x33])\n  },\n  key: Buffer.from([0x14, 0x6e, 0x0b, 0xe7, 0xab, 0xac, 0xd0, 0xd6]),\n  verifierHash: {\n    input: Buffer.from([0xfe, 0xa7, 0xd2, 0x76, 0x3b, 0x4b, 0x9e, 0x79]),\n    value: Buffer.from([0xd7, 0xaa, 0x0f, 0x6d, 0x30, 0x61, 0x34, 0x4e])\n  }\n};\n\n/**\n * Encrypts/decrypts XLSXs.\n * @private\n */\nvar Encryptor = /*#__PURE__*/function () {\n  function Encryptor() {\n    _classCallCheck(this, Encryptor);\n  }\n  _createClass(Encryptor, [{\n    key: \"encrypt\",\n    /**\n     * Encrypt the data with the password.\n     * @param {Buffer} data - The data to encrypt\n     * @param {string} password - The password\n     * @returns {Buffer} The encrypted data\n     */\n    value: function encrypt(data, password) {\n      // Generate a random key to use to encrypt the document. Excel uses 32 bytes. We'll use the password to encrypt this key.\n      // N.B. The number of bits needs to correspond to an algorithm available in crypto (e.g. aes-256-cbc).\n      var packageKey = crypto.randomBytes(32);\n\n      // Create the encryption info. We'll use this for all of the encryption operations and for building the encryption info XML entry\n      var encryptionInfo = {\n        package: {\n          // Info on the encryption of the package.\n          cipherAlgorithm: 'AES',\n          // Cipher algorithm to use. Excel uses AES.\n          cipherChaining: 'ChainingModeCBC',\n          // Cipher chaining mode to use. Excel uses CBC.\n          saltValue: crypto.randomBytes(16),\n          // Random value to use as encryption salt. Excel uses 16 bytes.\n          hashAlgorithm: 'SHA512',\n          // Hash algorithm to use. Excel uses SHA512.\n          hashSize: 64,\n          // The size of the hash in bytes. SHA512 results in 64-byte hashes\n          blockSize: 16,\n          // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n          keyBits: packageKey.length * 8 // The number of bits in the package key.\n        },\n\n        key: {\n          // Info on the encryption of the package key.\n          cipherAlgorithm: 'AES',\n          // Cipher algorithm to use. Excel uses AES.\n          cipherChaining: 'ChainingModeCBC',\n          // Cipher chaining mode to use. Excel uses CBC.\n          saltValue: crypto.randomBytes(16),\n          // Random value to use as encryption salt. Excel uses 16 bytes.\n          hashAlgorithm: 'SHA512',\n          // Hash algorithm to use. Excel uses SHA512.\n          hashSize: 64,\n          // The size of the hash in bytes. SHA512 results in 64-byte hashes\n          blockSize: 16,\n          // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n          spinCount: 100000,\n          // The number of times to iterate on a hash of a password. It MUST NOT be greater than 10,000,000. Excel uses 100,000.\n          keyBits: 256 // The length of the key to generate from the password. Must be a multiple of 8. Excel uses 256.\n        }\n      };\n\n      /* Package Encryption */\n\n      // Encrypt package using the package key.\n      var encryptedPackage = this._cryptPackage(true, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, encryptionInfo.package.hashAlgorithm, encryptionInfo.package.blockSize, encryptionInfo.package.saltValue, packageKey, data);\n\n      /* Data Integrity */\n\n      // Create the data integrity fields used by clients for integrity checks.\n      // First generate a random array of bytes to use in HMAC. The docs say to use the same length as the key salt, but Excel seems to use 64.\n      var hmacKey = crypto.randomBytes(64);\n\n      // Then create an initialization vector using the package encryption info and the appropriate block key.\n      var hmacKeyIV = this._createIV(encryptionInfo.package.hashAlgorithm, encryptionInfo.package.saltValue, encryptionInfo.package.blockSize, BLOCK_KEYS.dataIntegrity.hmacKey);\n\n      // Use the package key and the IV to encrypt the HMAC key\n      var encryptedHmacKey = this._crypt(true, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, packageKey, hmacKeyIV, hmacKey);\n\n      // Now create the HMAC\n      var hmacValue = this._hmac(encryptionInfo.package.hashAlgorithm, hmacKey, encryptedPackage);\n\n      // Next generate an initialization vector for encrypting the resulting HMAC value.\n      var hmacValueIV = this._createIV(encryptionInfo.package.hashAlgorithm, encryptionInfo.package.saltValue, encryptionInfo.package.blockSize, BLOCK_KEYS.dataIntegrity.hmacValue);\n\n      // Now encrypt the value\n      var encryptedHmacValue = this._crypt(true, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, packageKey, hmacValueIV, hmacValue);\n\n      // Put the encrypted key and value on the encryption info\n      encryptionInfo.dataIntegrity = {\n        encryptedHmacKey: encryptedHmacKey,\n        encryptedHmacValue: encryptedHmacValue\n      };\n\n      /* Key Encryption */\n\n      // Convert the password to an encryption key\n      var key = this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.key);\n\n      // Encrypt the package key with the\n      encryptionInfo.key.encryptedKeyValue = this._crypt(true, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, key, encryptionInfo.key.saltValue, packageKey);\n\n      /* Verifier hash */\n\n      // Create a random byte array for hashing\n      var verifierHashInput = crypto.randomBytes(16);\n\n      // Create an encryption key from the password for the input\n      var verifierHashInputKey = this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.verifierHash.input);\n\n      // Use the key to encrypt the verifier input\n      encryptionInfo.key.encryptedVerifierHashInput = this._crypt(true, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, verifierHashInputKey, encryptionInfo.key.saltValue, verifierHashInput);\n\n      // Create a hash of the input\n      var verifierHashValue = this._hash(encryptionInfo.key.hashAlgorithm, verifierHashInput);\n\n      // Create an encryption key from the password for the hash\n      var verifierHashValueKey = this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.verifierHash.value);\n\n      // Use the key to encrypt the hash value\n      encryptionInfo.key.encryptedVerifierHashValue = this._crypt(true, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, verifierHashValueKey, encryptionInfo.key.saltValue, verifierHashValue);\n\n      // Build the encryption info buffer\n      var encryptionInfoBuffer = this._buildEncryptionInfo(encryptionInfo);\n\n      // Create a new CFB\n      var output = cfb.utils.cfb_new();\n\n      // Add the encryption info and encrypted package\n      cfb.utils.cfb_add(output, \"EncryptionInfo\", encryptionInfoBuffer);\n      cfb.utils.cfb_add(output, \"EncryptedPackage\", encryptedPackage);\n\n      // Delete the SheetJS entry that is added at initialization\n      cfb.utils.cfb_del(output, \"\\x01Sh33tJ5\");\n\n      // Write to a buffer and return\n      output = cfb.write(output);\n\n      // The cfb library writes to a Uint8array in the browser. Convert to a Buffer.\n      if (!Buffer.isBuffer(output)) output = Buffer.from(output);\n      return output;\n    }\n    /**\n     * Decrypt the data with the given password\n     * @param {Buffer} data - The data to decrypt\n     * @param {string} password - The password\n     * @returns {Promise.<Buffer>} The decrypted data\n     */\n  }, {\n    key: \"decryptAsync\",\n    value: function decryptAsync(data, password) {\n      var _this = this;\n      // Parse the CFB input and pull out the encryption info and encrypted package entries.\n      var parsed = cfb.parse(data);\n      var encryptionInfoBuffer = _.find(parsed.FileIndex, {\n        name: \"EncryptionInfo\"\n      }).content;\n      var encryptedPackageBuffer = _.find(parsed.FileIndex, {\n        name: \"EncryptedPackage\"\n      }).content;\n\n      // In the browser the CFB content is an array. Convert to a Buffer.\n      if (!Buffer.isBuffer(encryptionInfoBuffer)) encryptionInfoBuffer = Buffer.from(encryptionInfoBuffer);\n      if (!Buffer.isBuffer(encryptedPackageBuffer)) encryptedPackageBuffer = Buffer.from(encryptedPackageBuffer);\n      return externals.Promise.resolve().then(function () {\n        return _this._parseEncryptionInfoAsync(encryptionInfoBuffer);\n      }) // Parse the encryption info XML into an object\n      .then(function (encryptionInfo) {\n        // Convert the password into an encryption key\n        var key = _this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.key);\n\n        // Use the key to decrypt the package key\n        var packageKey = _this._crypt(false, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, key, encryptionInfo.key.saltValue, encryptionInfo.key.encryptedKeyValue);\n\n        // Use the package key to decrypt the package\n        return _this._cryptPackage(false, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, encryptionInfo.package.hashAlgorithm, encryptionInfo.package.blockSize, encryptionInfo.package.saltValue, packageKey, encryptedPackageBuffer);\n      });\n    }\n    /**\n     * Build the encryption info XML/buffer\n     * @param {{}} encryptionInfo - The encryption info object\n     * @returns {Buffer} The buffer\n     * @private\n     */\n  }, {\n    key: \"_buildEncryptionInfo\",\n    value: function _buildEncryptionInfo(encryptionInfo) {\n      // Map the object into the appropriate XML structure. Buffers are encoded in base 64.\n      var encryptionInfoNode = {\n        name: \"encryption\",\n        attributes: {\n          xmlns: \"http://schemas.microsoft.com/office/2006/encryption\",\n          'xmlns:p': \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\",\n          'xmlns:c': \"http://schemas.microsoft.com/office/2006/keyEncryptor/certificate\"\n        },\n        children: [{\n          name: \"keyData\",\n          attributes: {\n            saltSize: encryptionInfo.package.saltValue.length,\n            blockSize: encryptionInfo.package.blockSize,\n            keyBits: encryptionInfo.package.keyBits,\n            hashSize: encryptionInfo.package.hashSize,\n            cipherAlgorithm: encryptionInfo.package.cipherAlgorithm,\n            cipherChaining: encryptionInfo.package.cipherChaining,\n            hashAlgorithm: encryptionInfo.package.hashAlgorithm,\n            saltValue: encryptionInfo.package.saltValue.toString(\"base64\")\n          }\n        }, {\n          name: \"dataIntegrity\",\n          attributes: {\n            encryptedHmacKey: encryptionInfo.dataIntegrity.encryptedHmacKey.toString(\"base64\"),\n            encryptedHmacValue: encryptionInfo.dataIntegrity.encryptedHmacValue.toString(\"base64\")\n          }\n        }, {\n          name: \"keyEncryptors\",\n          children: [{\n            name: \"keyEncryptor\",\n            attributes: {\n              uri: \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\"\n            },\n            children: [{\n              name: \"p:encryptedKey\",\n              attributes: {\n                spinCount: encryptionInfo.key.spinCount,\n                saltSize: encryptionInfo.key.saltValue.length,\n                blockSize: encryptionInfo.key.blockSize,\n                keyBits: encryptionInfo.key.keyBits,\n                hashSize: encryptionInfo.key.hashSize,\n                cipherAlgorithm: encryptionInfo.key.cipherAlgorithm,\n                cipherChaining: encryptionInfo.key.cipherChaining,\n                hashAlgorithm: encryptionInfo.key.hashAlgorithm,\n                saltValue: encryptionInfo.key.saltValue.toString(\"base64\"),\n                encryptedVerifierHashInput: encryptionInfo.key.encryptedVerifierHashInput.toString(\"base64\"),\n                encryptedVerifierHashValue: encryptionInfo.key.encryptedVerifierHashValue.toString(\"base64\"),\n                encryptedKeyValue: encryptionInfo.key.encryptedKeyValue.toString(\"base64\")\n              }\n            }]\n          }]\n        }]\n      };\n\n      // Convert to an XML string\n      var xmlBuilder = new XmlBuilder();\n      var encryptionInfoXml = xmlBuilder.build(encryptionInfoNode);\n\n      // Convert to a buffer and prefix with the appropriate bytes\n      return Buffer.concat([ENCRYPTION_INFO_PREFIX, Buffer.from(encryptionInfoXml, \"utf8\")]);\n    }\n    /**\n     * Parse the encryption info from the XML/buffer\n     * @param {Buffer} buffer - The buffer\n     * @returns {Promise.<{}>} The parsed encryption info object\n     * @private\n     */\n  }, {\n    key: \"_parseEncryptionInfoAsync\",\n    value: function _parseEncryptionInfoAsync(buffer) {\n      // Pull off the prefix and convert to string\n      var xml = buffer.slice(ENCRYPTION_INFO_PREFIX.length).toString(\"utf8\");\n\n      // Parse the XML\n      var xmlParser = new XmlParser();\n      return xmlParser.parseAsync(xml).then(function (doc) {\n        // Pull out the relevant values for decryption and return\n        var keyDataNode = xmlq.findChild(doc, \"keyData\");\n        var keyEncryptorsNode = xmlq.findChild(doc, \"keyEncryptors\");\n        var keyEncryptorNode = xmlq.findChild(keyEncryptorsNode, \"keyEncryptor\");\n        var encryptedKeyNode = xmlq.findChild(keyEncryptorNode, \"p:encryptedKey\");\n        return {\n          package: {\n            cipherAlgorithm: keyDataNode.attributes.cipherAlgorithm,\n            cipherChaining: keyDataNode.attributes.cipherChaining,\n            saltValue: Buffer.from(keyDataNode.attributes.saltValue, \"base64\"),\n            hashAlgorithm: keyDataNode.attributes.hashAlgorithm,\n            blockSize: keyDataNode.attributes.blockSize\n          },\n          key: {\n            encryptedKeyValue: Buffer.from(encryptedKeyNode.attributes.encryptedKeyValue, \"base64\"),\n            cipherAlgorithm: encryptedKeyNode.attributes.cipherAlgorithm,\n            cipherChaining: encryptedKeyNode.attributes.cipherChaining,\n            saltValue: Buffer.from(encryptedKeyNode.attributes.saltValue, \"base64\"),\n            hashAlgorithm: encryptedKeyNode.attributes.hashAlgorithm,\n            spinCount: encryptedKeyNode.attributes.spinCount,\n            keyBits: encryptedKeyNode.attributes.keyBits\n          }\n        };\n      });\n    }\n    /**\n     * Calculate a hash of the concatenated buffers with the given algorithm.\n     * @param {string} algorithm - The hash algorithm.\n     * @param {Array.<Buffer>} buffers - The buffers to concat and hash\n     * @returns {Buffer} The hash\n     * @private\n     */\n  }, {\n    key: \"_hash\",\n    value: function _hash(algorithm) {\n      algorithm = algorithm.toLowerCase();\n      var hashes = crypto.getHashes();\n      if (hashes.indexOf(algorithm) < 0) throw new Error(\"Hash algorithm '\".concat(algorithm, \"' not supported!\"));\n      var hash = crypto.createHash(algorithm);\n      for (var _len = arguments.length, buffers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        buffers[_key - 1] = arguments[_key];\n      }\n      hash.update(Buffer.concat(buffers));\n      return hash.digest();\n    }\n    /**\n     * Calculate an HMAC of the concatenated buffers with the given algorithm and key\n     * @param {string} algorithm - The algorithm.\n     * @param {string} key - The key\n     * @param {Array.<Buffer>} buffers - The buffer to concat and HMAC\n     * @returns {Buffer} The HMAC\n     * @private\n     */\n  }, {\n    key: \"_hmac\",\n    value: function _hmac(algorithm, key) {\n      algorithm = algorithm.toLowerCase();\n      var hashes = crypto.getHashes();\n      if (hashes.indexOf(algorithm) < 0) throw new Error(\"HMAC algorithm '\".concat(algorithm, \"' not supported!\"));\n      var hmac = crypto.createHmac(algorithm, key);\n      for (var _len2 = arguments.length, buffers = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        buffers[_key2 - 2] = arguments[_key2];\n      }\n      hmac.update(Buffer.concat(buffers));\n      return hmac.digest();\n    }\n    /**\n     * Encrypt/decrypt input\n     * @param {boolean} encrypt - True to encrypt, false to decrypt\n     * @param {string} cipherAlgorithm - The cipher algorithm\n     * @param {sring} cipherChaining - The cipher chaining mode\n     * @param {Buffer} key - The encryption key\n     * @param {Buffer} iv - The initialization vector\n     * @param {Buffer} input - The input\n     * @returns {Buffer} The output\n     * @private\n     */\n  }, {\n    key: \"_crypt\",\n    value: function _crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, input) {\n      var algorithm = \"\".concat(cipherAlgorithm.toLowerCase(), \"-\").concat(key.length * 8);\n      if (cipherChaining === 'ChainingModeCBC') algorithm += '-cbc';else throw new Error(\"Unknown cipher chaining: \".concat(cipherChaining));\n      var cipher = crypto[encrypt ? 'createCipheriv' : 'createDecipheriv'](algorithm, key, iv);\n      cipher.setAutoPadding(false);\n      var output = cipher.update(input);\n      output = Buffer.concat([output, cipher.final()]);\n      return output;\n    }\n    /**\n     * Encrypt/decrypt the package\n     * @param {boolean} encrypt - True to encrypt, false to decrypt\n     * @param {string} cipherAlgorithm - The cipher algorithm\n     * @param {string} cipherChaining - The cipher chaining mode\n     * @param {string} hashAlgorithm - The hash algorithm\n     * @param {number} blockSize - The IV block size\n     * @param {Buffer} saltValue - The salt\n     * @param {Buffer} key - The encryption key\n     * @param {Buffer} input - The package input\n     * @returns {Buffer} The output\n     * @private\n     */\n  }, {\n    key: \"_cryptPackage\",\n    value: function _cryptPackage(encrypt, cipherAlgorithm, cipherChaining, hashAlgorithm, blockSize, saltValue, key, input) {\n      // The first 8 bytes is supposed to be the length, but it seems like it is really the length - 4..\n      var outputChunks = [];\n      var offset = encrypt ? 0 : PACKAGE_OFFSET;\n\n      // The package is encoded in chunks. Encrypt/decrypt each and concat.\n      var i = 0,\n        start = 0,\n        end = 0;\n      while (end < input.length) {\n        start = end;\n        end = start + PACKAGE_ENCRYPTION_CHUNK_SIZE;\n        if (end > input.length) end = input.length;\n\n        // Grab the next chunk\n        var inputChunk = input.slice(start + offset, end + offset);\n\n        // Pad the chunk if it is not an integer multiple of the block size\n        var remainder = inputChunk.length % blockSize;\n        if (remainder) inputChunk = Buffer.concat([inputChunk, Buffer.alloc(blockSize - remainder)]);\n\n        // Create the initialization vector\n        var iv = this._createIV(hashAlgorithm, saltValue, blockSize, i);\n\n        // Encrypt/decrypt the chunk and add it to the array\n        var outputChunk = this._crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, inputChunk);\n        outputChunks.push(outputChunk);\n        i++;\n      }\n\n      // Concat all of the output chunks.\n      var output = Buffer.concat(outputChunks);\n      if (encrypt) {\n        // Put the length of the package in the first 8 bytes\n        output = Buffer.concat([this._createUInt32LEBuffer(input.length, PACKAGE_OFFSET), output]);\n      } else {\n        // Truncate the buffer to the size in the prefix\n        var length = input.readUInt32LE(0);\n        output = output.slice(0, length);\n      }\n      return output;\n    }\n    /**\n     * Create a buffer of an integer encoded as a uint32le\n     * @param {number} value - The integer to encode\n     * @param {number} [bufferSize=4] The output buffer size in bytes\n     * @returns {Buffer} The buffer\n     * @private\n     */\n  }, {\n    key: \"_createUInt32LEBuffer\",\n    value: function _createUInt32LEBuffer(value) {\n      var bufferSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n      var buffer = Buffer.alloc(bufferSize);\n      buffer.writeUInt32LE(value, 0);\n      return buffer;\n    }\n    /**\n     * Convert a password into an encryption key\n     * @param {string} password - The password\n     * @param {string} hashAlgorithm - The hash algoritm\n     * @param {Buffer} saltValue - The salt value\n     * @param {number} spinCount - The spin count\n     * @param {number} keyBits - The length of the key in bits\n     * @param {Buffer} blockKey - The block key\n     * @returns {Buffer} The encryption key\n     * @private\n     */\n  }, {\n    key: \"_convertPasswordToKey\",\n    value: function _convertPasswordToKey(password, hashAlgorithm, saltValue, spinCount, keyBits, blockKey) {\n      // Password must be in unicode buffer\n      var passwordBuffer = Buffer.from(password, 'utf16le');\n\n      // Generate the initial hash\n      var key = this._hash(hashAlgorithm, saltValue, passwordBuffer);\n\n      // Now regenerate until spin count\n      for (var i = 0; i < spinCount; i++) {\n        var iterator = this._createUInt32LEBuffer(i);\n        key = this._hash(hashAlgorithm, iterator, key);\n      }\n\n      // Now generate the final hash\n      key = this._hash(hashAlgorithm, key, blockKey);\n\n      // Truncate or pad as needed to get to length of keyBits\n      var keyBytes = keyBits / 8;\n      if (key.length < keyBytes) {\n        var tmp = Buffer.alloc(keyBytes, 0x36);\n        key.copy(tmp);\n        key = tmp;\n      } else if (key.length > keyBytes) {\n        key = key.slice(0, keyBytes);\n      }\n      return key;\n    }\n    /**\n     * Create an initialization vector (IV)\n     * @param {string} hashAlgorithm - The hash algorithm\n     * @param {Buffer} saltValue - The salt value\n     * @param {number} blockSize - The size of the IV\n     * @param {Buffer|number} blockKey - The block key or an int to convert to a buffer\n     * @returns {Buffer} The IV\n     * @private\n     */\n  }, {\n    key: \"_createIV\",\n    value: function _createIV(hashAlgorithm, saltValue, blockSize, blockKey) {\n      // Create the block key from the current index\n      if (typeof blockKey === \"number\") blockKey = this._createUInt32LEBuffer(blockKey);\n\n      // Create the initialization vector by hashing the salt with the block key.\n      // Truncate or pad as needed to meet the block size.\n      var iv = this._hash(hashAlgorithm, saltValue, blockKey);\n      if (iv.length < blockSize) {\n        var tmp = Buffer.alloc(blockSize, 0x36);\n        iv.copy(tmp);\n        iv = tmp;\n      } else if (iv.length > blockSize) {\n        iv = iv.slice(0, blockSize);\n      }\n      return iv;\n    }\n  }]);\n  return Encryptor;\n}();\nmodule.exports = Encryptor;","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport React, { useRef, useEffect, useImperativeHandle, useCallback, useContext, useState, useMemo } from 'react';\nimport get from 'lodash/get';\nimport isNil from 'lodash/isNil';\nimport contains from 'dom-lib/contains';\nimport Overlay from './Overlay';\nimport { createChainedFunction, usePortal, useControlled } from '../utils';\nimport isOneOf from '../utils/isOneOf';\nimport OverlayContext from './OverlayContext';\nfunction mergeEvents(events, props) {\n  if (events === void 0) {\n    events = {};\n  }\n  if (props === void 0) {\n    props = {};\n  }\n  var nextEvents = {};\n  Object.keys(events).forEach(function (eventName) {\n    if (events[eventName]) {\n      var _props;\n      nextEvents[eventName] = createChainedFunction(events[eventName], (_props = props) === null || _props === void 0 ? void 0 : _props[eventName]);\n    }\n  });\n  return nextEvents;\n}\n\n/**\n * The reason that triggers closing of an overlay\n * - Clicking outside of the overlay\n * - Direct invocation of triggerRef.current.close()\n */\nexport var OverlayCloseCause;\n/**\n * Useful for mouseover and mouseout.\n * In order to resolve the node entering the mouseover element, a mouseout event and a mouseover event will be triggered.\n * https://javascript.info/mousemove-mouseover-mouseout-mouseenter-mouseleave\n * @param handler\n * @param event\n */\n\n(function (OverlayCloseCause) {\n  OverlayCloseCause[OverlayCloseCause[\"ClickOutside\"] = 0] = \"ClickOutside\";\n  OverlayCloseCause[OverlayCloseCause[\"ImperativeHandle\"] = 1] = \"ImperativeHandle\";\n})(OverlayCloseCause || (OverlayCloseCause = {}));\nfunction onMouseEventHandler(handler, event, delay) {\n  var target = event.currentTarget;\n  var related = event.relatedTarget || get(event, ['nativeEvent', 'toElement']);\n  if ((!related || related !== target) && !contains(target, related)) {\n    handler(event, delay);\n  }\n}\nvar defaultTrigger = ['hover', 'focus'];\nvar OverlayTrigger = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  var _useContext = useContext(OverlayContext),\n    overlayContainer = _useContext.overlayContainer;\n  var children = props.children,\n    _props$container = props.container,\n    container = _props$container === void 0 ? overlayContainer : _props$container,\n    controlId = props.controlId,\n    defaultOpen = props.defaultOpen,\n    _props$trigger = props.trigger,\n    trigger = _props$trigger === void 0 ? defaultTrigger : _props$trigger,\n    disabled = props.disabled,\n    followCursor = props.followCursor,\n    readOnly = props.readOnly,\n    plaintext = props.plaintext,\n    openProp = props.open,\n    delay = props.delay,\n    delayOpenProp = props.delayOpen,\n    delayCloseProp = props.delayClose,\n    enterable = props.enterable,\n    _props$placement = props.placement,\n    placement = _props$placement === void 0 ? 'bottomStart' : _props$placement,\n    speaker = props.speaker,\n    _props$rootClose = props.rootClose,\n    rootClose = _props$rootClose === void 0 ? true : _props$rootClose,\n    onClick = props.onClick,\n    onMouseOver = props.onMouseOver,\n    onMouseMove = props.onMouseMove,\n    onMouseOut = props.onMouseOut,\n    onContextMenu = props.onContextMenu,\n    onFocus = props.onFocus,\n    onBlur = props.onBlur,\n    onClose = props.onClose,\n    onExited = props.onExited,\n    rest = _objectWithoutPropertiesLoose(props, [\"children\", \"container\", \"controlId\", \"defaultOpen\", \"trigger\", \"disabled\", \"followCursor\", \"readOnly\", \"plaintext\", \"open\", \"delay\", \"delayOpen\", \"delayClose\", \"enterable\", \"placement\", \"speaker\", \"rootClose\", \"onClick\", \"onMouseOver\", \"onMouseMove\", \"onMouseOut\", \"onContextMenu\", \"onFocus\", \"onBlur\", \"onClose\", \"onExited\"]);\n  var _usePortal = usePortal({\n      container: container\n    }),\n    Portal = _usePortal.Portal,\n    containerElement = _usePortal.target;\n  var triggerRef = useRef();\n  var overlayRef = useRef();\n  var _useControlled = useControlled(openProp, defaultOpen),\n    open = _useControlled[0],\n    setOpen = _useControlled[1];\n  var _useState = useState(null),\n    cursorPosition = _useState[0],\n    setCursorPosition = _useState[1]; // Delay the timer to close/open the overlay\n  // When the cursor moves from the trigger to the overlay, the overlay will be closed.\n  // In order to keep the overlay open, a timer is used to delay the closing.\n\n  var delayOpenTimer = useRef(null);\n  var delayCloseTimer = useRef(null);\n  var delayOpen = isNil(delayOpenProp) ? delay : delayOpenProp;\n  var delayClose = isNil(delayCloseProp) ? delay : delayCloseProp; // Whether the cursor is on the overlay\n\n  var isOnOverlay = useRef(false); // Whether the cursor is on the trigger\n\n  var isOnTrigger = useRef(false);\n  useEffect(function () {\n    return function () {\n      if (!isNil(delayOpenTimer.current)) {\n        clearTimeout(delayOpenTimer.current);\n      }\n      if (!isNil(delayCloseTimer.current)) {\n        clearTimeout(delayCloseTimer.current);\n      }\n    };\n  }, []);\n  var handleOpen = useCallback(function (delay) {\n    var ms = _isUndefined(delay) ? delayOpen : delay;\n    if (ms && typeof ms === 'number') {\n      return delayOpenTimer.current = setTimeout(function () {\n        delayOpenTimer.current = null;\n        setOpen(true);\n      }, ms);\n    }\n    setOpen(true);\n  }, [delayOpen, setOpen]);\n  var handleClose = useCallback(function (delay, callback) {\n    var ms = _isUndefined(delay) ? delayClose : delay;\n    if (ms && typeof ms === 'number') {\n      return delayCloseTimer.current = setTimeout(function () {\n        delayCloseTimer.current = null;\n        setOpen(false);\n        callback === null || callback === void 0 ? void 0 : callback();\n      }, ms);\n    }\n    setOpen(false);\n    callback === null || callback === void 0 ? void 0 : callback();\n  }, [delayClose, setOpen]);\n  var handleExited = useCallback(function () {\n    setCursorPosition(null);\n  }, []);\n  useImperativeHandle(ref, function () {\n    return {\n      get root() {\n        return triggerRef.current;\n      },\n      get overlay() {\n        var _overlayRef$current;\n        return (_overlayRef$current = overlayRef.current) === null || _overlayRef$current === void 0 ? void 0 : _overlayRef$current.child;\n      },\n      open: handleOpen,\n      close: function close(delay) {\n        return handleClose(delay, function () {\n          return onClose === null || onClose === void 0 ? void 0 : onClose(OverlayCloseCause.ImperativeHandle);\n        });\n      },\n      updatePosition: function updatePosition() {\n        var _overlayRef$current2, _overlayRef$current2$;\n        (_overlayRef$current2 = overlayRef.current) === null || _overlayRef$current2 === void 0 ? void 0 : (_overlayRef$current2$ = _overlayRef$current2.updatePosition) === null || _overlayRef$current2$ === void 0 ? void 0 : _overlayRef$current2$.call(_overlayRef$current2);\n      }\n    };\n  });\n  /**\n   * Close after the cursor leaves.\n   */\n\n  var handleCloseWhenLeave = useCallback(function () {\n    // When the cursor is not on the overlay and not on the trigger, it is closed.\n    if (!isOnOverlay.current && !isOnTrigger.current) {\n      handleClose();\n    }\n  }, [handleClose]);\n  /**\n   * Toggle open and closed state.\n   */\n\n  var handleOpenState = useCallback(function () {\n    if (open) {\n      handleCloseWhenLeave();\n    } else {\n      handleOpen();\n    }\n  }, [open, handleCloseWhenLeave, handleOpen]);\n  var handleDelayedOpen = useCallback(function () {\n    if (!enterable) {\n      return handleOpen();\n    }\n    isOnTrigger.current = true;\n    if (!isNil(delayCloseTimer.current)) {\n      clearTimeout(delayCloseTimer.current);\n      delayCloseTimer.current = null;\n      return handleOpen();\n    }\n    if (open) {\n      return;\n    }\n    handleOpen();\n  }, [enterable, open, handleOpen]);\n  var handleDelayedClose = useCallback(function () {\n    if (!enterable) {\n      return handleClose();\n    }\n    isOnTrigger.current = false;\n    if (!isNil(delayOpenTimer.current)) {\n      clearTimeout(delayOpenTimer.current);\n      delayOpenTimer.current = null;\n      return;\n    }\n    if (!open || !isNil(delayCloseTimer.current)) {\n      return;\n    }\n    delayCloseTimer.current = setTimeout(function () {\n      if (!isNil(delayCloseTimer.current)) {\n        clearTimeout(delayCloseTimer.current);\n        delayCloseTimer.current = null;\n      }\n      handleCloseWhenLeave();\n    }, 200);\n  }, [enterable, open, handleClose, handleCloseWhenLeave]);\n  var handleSpeakerMouseEnter = useCallback(function () {\n    isOnOverlay.current = true;\n  }, []);\n  var handleSpeakerMouseLeave = useCallback(function () {\n    isOnOverlay.current = false;\n    if (!isOneOf('click', trigger) && !isOneOf('contextMenu', trigger) && !isOneOf('active', trigger)) {\n      handleCloseWhenLeave();\n    }\n  }, [handleCloseWhenLeave, trigger]);\n  var handledMoveOverlay = useCallback(function (event) {\n    setCursorPosition(function () {\n      return {\n        top: event.pageY,\n        left: event.pageX,\n        clientTop: event.clientX,\n        clientLeft: event.clientY\n      };\n    });\n  }, []);\n  var preventDefault = useCallback(function (event) {\n    event.preventDefault();\n  }, []);\n  var triggerEvents = useMemo(function () {\n    // Pass events by props\n    var events = {\n      onClick: onClick,\n      onContextMenu: onContextMenu,\n      onMouseOver: onMouseOver,\n      onMouseOut: onMouseOut,\n      onFocus: onFocus,\n      onBlur: onBlur,\n      onMouseMove: onMouseMove\n    }; // When trigger is disabled, no predefined event listeners are added.\n\n    if (disabled || readOnly || plaintext || trigger === 'none') {\n      return events;\n    } // Get the cursor position through onMouseMove.\n    // https://rsuitejs.com/components/tooltip/#follow-cursor\n\n    if (followCursor) {\n      events.onMouseMove = createChainedFunction(handledMoveOverlay, onMouseMove);\n    } // The `click` event is usually used in `toggle` scenarios.\n    // The first click will open and the second click will close.\n\n    if (isOneOf('click', trigger)) {\n      events.onClick = createChainedFunction(handleOpenState, events.onClick);\n      return events;\n    } // The difference between it and the click event is that it does not trigger the close.\n\n    if (isOneOf('active', trigger)) {\n      events.onClick = createChainedFunction(handleDelayedOpen, events.onClick);\n      return events;\n    }\n    if (isOneOf('hover', trigger)) {\n      var onMouseOverListener = function onMouseOverListener(e) {\n        return onMouseEventHandler(handleDelayedOpen, e);\n      };\n      var onMouseOutListener = function onMouseOutListener(e) {\n        return onMouseEventHandler(handleDelayedClose, e);\n      };\n      events.onMouseOver = createChainedFunction(onMouseOverListener, events.onMouseOver);\n      events.onMouseOut = createChainedFunction(onMouseOutListener, events.onMouseOut);\n    }\n    if (isOneOf('focus', trigger)) {\n      events.onFocus = createChainedFunction(handleDelayedOpen, events.onFocus);\n      events.onBlur = createChainedFunction(handleDelayedClose, events.onBlur);\n    }\n    if (isOneOf('contextMenu', trigger)) {\n      events.onContextMenu = createChainedFunction(preventDefault, handleOpenState, events.onContextMenu);\n    }\n    return events;\n  }, [disabled, followCursor, handleDelayedClose, handleDelayedOpen, handleOpenState, handledMoveOverlay, onBlur, onClick, onContextMenu, onFocus, onMouseMove, onMouseOut, onMouseOver, plaintext, preventDefault, readOnly, trigger]);\n  var renderOverlay = function renderOverlay() {\n    var overlayProps = _extends({}, rest, {\n      rootClose: rootClose,\n      triggerTarget: triggerRef,\n      onClose: trigger !== 'none' ? createChainedFunction(handleClose, function () {\n        return onClose === null || onClose === void 0 ? void 0 : onClose(OverlayCloseCause.ClickOutside);\n      }) : undefined,\n      onExited: createChainedFunction(followCursor ? handleExited : undefined, onExited),\n      placement: placement,\n      container: containerElement,\n      open: open\n    });\n    var speakerProps = {\n      id: controlId\n    }; // The purpose of adding mouse entry and exit events to the Overlay is to record whether the current cursor is on the Overlay.\n    // When `trigger` is equal to `hover`, if the cursor leaves the `triggerTarget` and stays on the Overlay,\n    // the Overlay will continue to remain open.\n\n    if (trigger !== 'none' && enterable) {\n      speakerProps.onMouseEnter = handleSpeakerMouseEnter;\n      speakerProps.onMouseLeave = handleSpeakerMouseLeave;\n    }\n    return /*#__PURE__*/React.createElement(Overlay, _extends({}, overlayProps, {\n      ref: overlayRef,\n      childrenProps: speakerProps,\n      followCursor: followCursor,\n      cursorPosition: cursorPosition\n    }), typeof speaker === 'function' ? function (props, ref) {\n      return speaker(_extends({}, props, {\n        onClose: handleClose\n      }), ref);\n    } : speaker);\n  };\n  if (typeof children === 'object' && children.type === React.Fragment || typeof children === 'string') {\n    console.error('[rsuite] The OverlayTrigger component does not accept strings or Fragments as child.');\n  }\n  return /*#__PURE__*/React.createElement(React.Fragment, null, typeof children === 'function' ? children(triggerEvents, triggerRef) : /*#__PURE__*/React.cloneElement(children, _extends({\n    ref: triggerRef,\n    'aria-describedby': controlId\n  }, mergeEvents(triggerEvents, children.props))), /*#__PURE__*/React.createElement(Portal, null, renderOverlay()));\n});\nOverlayTrigger.displayName = 'OverlayTrigger';\nexport default OverlayTrigger;","map":null,"metadata":{},"sourceType":"module"}